!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.Ndex=t():e.Ndex=t()}(this,function(){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={exports:{},id:r,loaded:!1};return e[r].call(o.exports,o,o.exports,t),o.loaded=!0,o.exports}var n={};return t.m=e,t.c=n,t.p="",t(0)}([function(e,t,n){var r,o,a,i;o=n(1),r=n(2),i=n(4),a=function(){function e(){this.connections={}}return e.prototype.connect=function(e,t,n){var a,s,u;return u=null!=n?n:{},a=u.adapter,s=u.options,new Promise(function(n){return function(u,c){var l;if(!a){if(l=n.connections[e])return c(new Error("Already connected to “"+e+"”"));l=new o(e,t,s),a=n.connections[e]=n.getAdapter(l)}return a.handleMethod("open").then(function(e){return a.proxyObjectStoresNamespace(e),u(a)}).catch(function(t){return a instanceof i?(a=n.connections[e]=new r(l),console.info("Ndex: Fallbacking to BrowserAdapter for “"+e+"” because “"+t+"”"),u(n.connect(null,null,{adapter:a}))):c("Ndex: "+t)})}}(this))},e.prototype.getAdapter=function(e){var t;return new(t=this.getAdapterClass())(e)},e.prototype.getAdapterClass=function(){return this.workersAreSupported()?i:r},e.prototype.workersAreSupported=function(e){return null==e&&(e=window),null!=this._workersAreSupported?this._workersAreSupported:this._workersAreSupported="Worker"in e},e}(),e.exports=new a},function(e,t,n){var r,o=[].slice;r=function(){var e;return e={},e.API=function(){function t(t,n,r){this.name=t,this.migrations=n,this.options=null!=r?r:{},this.database=null,this.queue={},this.logging=new e.Logging}return t.prototype.CONNECTION_TIMEOUT=5e3,t.prototype.REQUEST_TIMEOUT=5e3,t.prototype.parseMigrations=function(e){var t,n;return(n=e.version)&&(this.version=n,delete e.version),t=Object.keys(e).sort(),t.map(function(t){return function(t){var r,o,a;return n=parseInt(t),a=t.match(/_(.+)/),o=a?a[1].replace(/(\w)([A-Z])/g,function(e,t,n){return t+" "+n.toLowerCase()}):"",r=e[t]||[],Array.isArray(r)||(r=[r]),{version:n,title:o,actions:r,key:t}}}(this))},t.prototype.deleteDatabase=function(){return new Promise(function(e){return function(t){var n;return e.database?(e.close(),n=indexedDB.deleteDatabase(e.database.name),n.onsuccess=function(e){return setTimeout(function(){return t()},0)}):t()}}(this))},t.prototype.open=function(t){var n;return n=(null!=t?t:{}).withoutVersion,this.dbPromise?this.dbPromise:this.dbPromise=new Promise(function(t){return function(r,o){var a,i,s,u,c,l;if(!self.indexedDB)return o("indexedDB isn’t supported");s=t.parseMigrations(t.migrations);try{l=n?void 0:t.version||s.length+1,c=indexedDB.open(t.name,l),a=null!=(u=t.options.connectionTimeout)?u:t.CONNECTION_TIMEOUT,null!=a&&a>-1&&(c.__timeout=setTimeout(function(){if(!c.__handled)return c.__timedout=!0,o(new Error("Connection timed out"))},a))}catch(e){if(i=e,clearTimeout(c.__timeout),c.__timedout)return;return c.__handled=!0,o(i.message||i.name)}return c.onupgradeneeded=function(t){var n,r,o,a,i,u,l,d,m,h,f,p;if(clearTimeout(c.__timeout),!c.__timedout){for(c.__handled=!0,r=t.target.result,p=t.target.transaction,d=new e.Migration(r,p),d.createObjectStore("migrations",{keyPath:"version"}),f=[],o=0,i=s.length;o<i;o++){for(l=s[o],h=l.actions,a=0,u=h.length;a<u;a++)n=h[a],"function"==typeof d[m=n.type]&&d[m].apply(d,n.args);f.push(p.objectStore("migrations").put(l))}return f}},c.onsuccess=function(e){var n,o;if(clearTimeout(c.__timeout),!c.__timedout)return c.__handled=!0,n=e.target.result,o=[].slice.call(n.objectStoreNames),t.createNamespaceForObjectStores(o),n.onversionchange=function(){return t.close()},t.database=n,r(o)},c.onerror=function(e){if(clearTimeout(c.__timeout),!c.__timedout)return c.__handled=!0,n||"VersionError"!==c.error.name?o(c.error.message||c.error.name):(t.close(),t.open({withoutVersion:!0}).then(r).catch(o))}}}(this))},t.prototype.close=function(){if(this.dbPromise&&delete this.dbPromise,this.database)return this.database.close()},t.prototype.get=function(e,t,n){return new Promise(function(r){return function(o,a){return Array.isArray(t)?Promise.all(t.map(function(t){return r.get(e,t)})).then(o).catch(a):r.enqueue("read",e,a,function(i){var s;return r.logging.addRequest(i,"get",e,n,{key:t}),s={method:"get",args:t,transaction:i,reject:a,objectStoreName:e,indexName:n},r.createRequest(s,function(e){var t;return t=e.target.result,void 0===t&&(t=null),o(t)})})}}(this))},t.prototype.getFirst=function(e,t){return new Promise(function(n){return function(r,o){return n.enqueue("read",e,o,function(a){var i;return n.logging.addRequest(a,"getFirst",e,t),i={method:"openCursor",transaction:a,reject:o,objectStoreName:e,indexName:t},n.createRequest(i,function(e){var t,n,o,a;return o=e.target,n=o.source,(t=o.result)?(a=t.value,n.keyPath||(a._key=t.key),r(a)):r(null)})})}}(this))},t.prototype.getAll=function(e,t){return new Promise(function(n){return function(r,o){return n.enqueue("read",e,o,function(a){var i,s;return n.logging.addRequest(a,"getAll",e,t),s=[],i={method:"openCursor",transaction:a,reject:o,objectStoreName:e,indexName:t},n.createRequest(i,function(e){var t,n,o,a;return o=e.target,n=o.source,(t=e.target.result)?(a=t.value,n.keyPath||(a._key=t.key),s.push(a),t.continue()):r(s)})})}}(this))},t.prototype.count=function(e,t){return new Promise(function(n){return function(r,o){return n.enqueue("read",e,o,function(a){var i;return n.logging.addRequest(a,"count",e,t),i={method:"count",transaction:a,reject:o,objectStoreName:e,indexName:t},n.createRequest(i,function(e){var t;return t=e.target.result,t||(t=0),r(t)})})}}(this))},t.prototype.add=function(e,t,n){var r;return void 0===n&&(r=[null,t],t=r[0],n=r[1]),new Promise(function(r){return function(o,a){return!t&&Array.isArray(n)?Promise.all(n.map(function(t){return r.add(e,t)})).then(o).catch(a):t&&Array.isArray(t)&&Array.isArray(n)?Promise.all(t.map(function(t,o){return r.add(e,t,n[o])})).then(o).catch(a):r.enqueue("write",e,a,function(i){var s,u;return r.logging.addRequest(i,"add",e,null,{key:t,data:n}),s=t?[n,t]:[n],u={method:"put",args:s,transaction:i,objectStoreName:e,reject:a},r.createRequest(u,function(e){return n._key=e.target.result,o(n)})})}}(this))},t.prototype.update=function(e,t,n){return new Promise(function(r){return function(o,a){return r.enqueue("write",e,a,function(i){var s;return r.logging.addRequest(i,"update",e,null,{key:t,data:n}),s={method:"get",args:t,transaction:i,objectStoreName:e,reject:a},r.createRequest(s,function(u){var c,l,d,m,h,f,p;return p=u.target,f=p.source,h=f.keyPath,m=!!h,l=p.result,void 0===l?(l=n,m&&(l[h]=t)):(d=function(e,t){var n,r,o;r=[];for(n in e)o=e[n],"object"!=typeof o?r.push(t[n]=o):d(o,t[n]);return r})(n,l),c=m?[l]:[l,t],s={method:"put",args:c,transaction:i,objectStoreName:e,reject:a},r.createRequest(s,function(e){return o(l)})})})}}(this))},t.prototype.increment=function(e,t,n,r){return null==n&&(n=1),new Promise(function(o){return function(a,i){return o.enqueue("write",e,i,function(s){var u;return o.logging.addRequest(s,r?"decrement":"increment",e,null,{key:t,data:n}),u={method:"get",args:t,transaction:s,objectStoreName:e,reject:i},o.createRequest(u,function(c){var l,d,m,h,f,p,g;return g=c.target,p=g.source,f=p.keyPath,h=!!f,d=g.result,h?(m=function(e,t){var n,o,a;o=[];for(n in e)a=e[n],"object"!=typeof a?(t[n]||(t[n]=0),o.push(t[n]+=r?-a:a)):m(a,t[n]);return o})(n,d):(d||(d=0),d+=r?-n:n),l=h?[d]:[d,t],u={method:"put",args:l,transaction:s,objectStoreName:e,reject:i},o.createRequest(u,function(e){return a(d)})})})}}(this))},t.prototype.decrement=function(e,t,n){return this.increment(e,t,n,!0)},t.prototype.delete=function(e,t){return new Promise(function(n){return function(r,o){return Array.isArray(t)?Promise.all(t.map(function(t){return n.delete(e,t)})).then(r).catch(o):n.enqueue("write",e,o,function(a){var i;return n.logging.addRequest(a,"delete",e,null,{key:t}),i={method:"delete",args:t,transaction:a,objectStoreName:e,reject:o},n.createRequest(i,function(e){return r(t)})})}}(this))},t.prototype.deleteWhere=function(e,t,n){return t.remove=!0,this.where(e,t,n)},t.prototype.clear=function(e){return new Promise(function(t){return function(n,r){return t.enqueue("write",e,r,function(o){var a;return t.logging.addRequest(o,"clear",e),a={method:"clear",transaction:o,objectStoreName:e,reject:r},t.createRequest(a,function(e){return n()})})}}(this))},t.prototype.clearAll=function(){return new Promise(function(e){return function(t,n){var r;return r=o.call(e.database.objectStoreNames),r=r.filter(function(e){return"migrations"!==e}),Promise.all(r.map(function(t){return e.clear(t)})).then(t).catch(n)}}(this))},t.prototype.reset=function(e,t,n){return new Promise(function(r){return function(o,a){return r.clear(e).then(function(){return r.add(e,t,n).then(o).catch(a)}).catch(a)}}(this))},t.prototype.index=function(e,t){return this.createNamespaceForIndex(t,e)},t.prototype.where=function(e,t,n){var r;return r=t.remove?"write":"read",new Promise(function(o){return function(a,i){return o.enqueue(r,e,i,function(r){var s,u,c,l,d,m,h,f,p,g,b,j,y,v,N,S,q,_,k,x,w,A,P,T,I,O,R,M,E,F,L,C,D;o.logging.addRequest(r,"where",e,n,{data:t}),x=t.lt,w=t.lteq,g=t.gt,b=t.gteq,m=t.eq,_=t.limit,A=t.offset,P=t.only,l=t.contains,p=t.except,F=t.uniq,T=t.order,M=t.remove,L=Array.isArray(F)?F:F?[F]:[],T="desc"===T?"prev":"next",c={},R={lt:x,lteq:w,gt:g,gteq:b,eq:m};for(S in R)D=R[S],void 0!==D&&(v="gteq"===S||"lteq"===S,y="eq"===S,N="gt"===S||"gteq"===S,u=y?"exact":N?"lower":"upper",c[u]={value:D,open:!v});return O=null,h=!1,k=c.lower,C=c.upper,f=c.exact,f?(h=Array.isArray(m))?(m.sort(),k={value:m[0],open:!1},C={value:m[m.length-1],open:!1},O=IDBKeyRange.bound(k.value,C.value,k.open,C.open)):O=IDBKeyRange.only(f.value):k&&C?O=IDBKeyRange.bound(k.value,C.value,k.open,C.open):k?O=IDBKeyRange.lowerBound(k.value,k.open):C&&(O=IDBKeyRange.upperBound(C.value,C.open)),E=[],d=0,q={},j=function(e,t,n){return Array.isArray(n)||(n=[n]),n.indexOf(e[t])!==-1},s=O?[O,T]:void 0,I={method:"openCursor",args:s,transaction:r,reject:i,objectStoreName:e,indexName:n},o.createRequest(I,function(e){var t,n,r,i,s,u,c,f;if(c=e.target,u=c.source,!(n=e.target.result))return a(E);f=n.value,h&&(P||(P={}),P[u.keyPath]=m);for(S in P)if(D=P[S],!j(f,S,D))return n.continue();for(S in l)if(D=l[S],Array.isArray(D)||(D=[D]),t=f[S],Array.isArray(t)||(t=[t]),!o.intersect(t,D).length)return n.continue();for(S in p)if(D=p[S],j(f,S,D))return n.continue();for(r=0,s=L.length;r<s;r++){if(S=L[r],i=q[S]||(q[S]=[]),i.indexOf(f[S])!==-1)return n.continue();q[S].push(f[S])}if(d++,A&&d<=A)return n.continue();if(E.push(f),M&&n.delete(),_){if("function"==typeof _&&_(E))return a(E);if(_===E.length)return a(E)}return n.continue()})})}}(this))},t.prototype.getMethodsForObjectStore=function(){return this._getMethodsForObjectStore||(this._getMethodsForObjectStore=["get","getFirst","getAll","count","add","update","increment","decrement","delete","deleteWhere","clear","reset","index","where"])},t.prototype.getMethodsForIndex=function(){return this._getMethodsForIndex||(this._getMethodsForIndex=["get","getFirst","getAll","count","where","deleteWhere"])},t.prototype.createNamespaceForObjectStores=function(e,t){var n,r,o,a;for(null==e&&(e=[]),null==t&&(t=this),a=[],n=0,r=e.length;n<r;n++)o=e[n],"migrations"!==o&&a.push(this.createNamespaceForObjectStore(o,t));return a},t.prototype.createNamespaceForObjectStore=function(e,t){var n;return null==t&&(t=this),n=t[e]={},this.getMethodsForObjectStore().forEach(function(r){return function(r){return n[r]=function(){return t[r].apply(t,[e].concat(o.call(arguments)))}}}(this)),n},t.prototype.createNamespaceForIndex=function(e,t,n){var r;return null==n&&(n=this),r={},this.getMethodsForIndex().forEach(function(a){return function(a){return r[a]=function(){return n[a].apply(n,[t].concat(o.call(arguments),[e]))}}}(this)),r},t.prototype.getObjectStore=function(e){var t,n,r,o;return o=e.transaction,r=e.objectStoreName,t=e.indexName,n=o.objectStore(r),t?n.index(t):n},t.prototype.createRequest=function(e,t){var n,r,o,a,i,s,u,c,l,d;return o=e.method,n=e.args,d=e.transaction,i=e.objectStoreName,r=e.indexName,u=e.reject,a=d.objectStore(i),r&&(a=a.index(r)),Array.isArray(n)||(n=[n]),c=a[o].apply(a,n),l=null!=(s=this.options.requestTimeout)?s:this.REQUEST_TIMEOUT,null!=l&&l>-1&&(c.__timeout=setTimeout(function(){if(!c.__handled){c.__timedout=!0;try{return d.abort()}catch(e){}}},l)),c.onsuccess=function(e){if(clearTimeout(c.__timeout),!c.__timedout)return c.__handled=!0,t(e)},c.onerror=function(e){return clearTimeout(c.__timeout),c.__handled=!0,"function"==typeof u?u(c.error):void 0},c},t.prototype.createTransaction=function(e,t,n){return this.open().then(function(r){return function(){var o,a;try{a=r.database.transaction([t],e)}catch(e){o=e}return n(a)}}(this)).catch(function(e){return function(e){throw e}}(this))},t.prototype.intersect=function(e,t){var n,r,o;for(n=0,r=0,o=[];n<e.length&&r<t.length;)e[n]<t[r]?n++:e[n]>t[r]?r++:(o.push(e[n]),n++,r++);return o},t.prototype.enqueue=function(e,t,n,r){var o,a;return(o=this.queue)[t]||(o[t]=[]),a={readwrite:e,objectStoreName:t,reject:n,callback:r},this.queue[t].length||this.scheduleTransaction(t),this.queue[t].push(a)},t.prototype.scheduleTransaction=function(e){return setTimeout(function(t){return function(){var n,r,o,a;return a=t.queue[e].splice(0),r=a.map(function(e){return e.readwrite}),o=r.some(function(e){return"write"===e}),n=o?"readwrite":"readonly",t.createTransaction(n,e,function(n){var r,o,i,s,u;for(t.logging.addTransaction(n,e),u=[],o=0,i=a.length;o<i;o++){s=a[o];try{u.push(s.callback(n))}catch(e){r=e,u.push(s.reject(r))}}return u})}}(this),0)},t}(),e.Migration=function(){function e(e,t){this.db=e,this.transaction=t}return e.prototype.createObjectStore=function(e,t){if(!this.db.objectStoreNames.contains(e))return this.db.createObjectStore(e,t)},e.prototype.deleteObjectStore=function(e){if(this.db.objectStoreNames.contains(e))return this.db.deleteObjectStore(e)},e.prototype.createIndex=function(e,t,n,r){var o;if(o=this.transaction.objectStore(e),!o||!o.indexNames.contains(t))return o.createIndex(t,n,r)},e.prototype.deleteIndex=function(e,t){var n;if(n=this.transaction.objectStore(e),n&&n.indexNames.contains(t))return n.deleteIndex(t)},e}(),e.Logging=function(){function e(){this.queues=[]}return e.prototype.addTransaction=function(e,t){var n;if(e&&this.handleLog)return this.queues.push({transaction:e,objectStoreNames:t,requests:[],start:Date.now()}),n=function(e){return function(t){return e.logTransaction(t.target)}}(this),e.onabort=n,e.onerror=n,e.oncomplete=n},e.prototype.addRequest=function(e,t,n,r,o){var a;if(e&&this.handleLog&&(a=this.queues.filter(function(t){return t.transaction===e})[0]))return a.requests.push({method:t,objectStoreName:n,indexName:r,data:o})},e.prototype.logTransaction=function(e){var t,n,r,o,a,i,s,u,c,l,d,m,h,f,p,g;if(e&&this.handleLog&&(d=this.queues.filter(function(t){return t.transaction===e})[0])){for(c="readwrite"===d.transaction.mode?"write":"read ",p=d.requests.length,n=Date.now(),g=n-d.start,this.handleLog({type:"transaction.start",data:"Ndex: "+c+" "+d.objectStoreNames+" "+g+"ms ("+p+" request"+(p>1?"s":"")+")"}),m=d.requests,o=0,i=m.length;o<i;o++){switch(f=m[o],u=f.method,l=f.objectStoreName,r=f.indexName,t=f.data,t&&(h=t,a=h.key,t=h.data),s=[],u){case"get":s=["GET",a,"FROM",l];break;case"getFirst":s=["GET FIRST",a,"FROM",l];break;case"getAll":s=["GET ALL","FROM",l];break;case"count":s=["COUNT","FROM",l];break;case"add":s=["ADD",JSON.stringify(t),"TO",l],a&&(s=s.concat(["WITH KEY",a]));break;case"update":s=["UPDATE",a,"FROM",l,"SET",JSON.stringify(t)];break;case"increment":"object"==typeof t&&(t=JSON.stringify(t)),s=["INCREMENT",t,"TO KEY",a,"FROM",l];break;case"decrement":"object"==typeof t&&(t=JSON.stringify(t)),s=["DECREMENT",t,"TO KEY",a,"FROM",l];break;case"delete":s=["DELETE",a,"FROM",l];break;case"clear":s=["CLEAR",l];break;case"where":"function"==typeof t.limit&&(t.limit="[FUNCTION]"),s=["WHERE",JSON.stringify(t),"FROM",l]}r&&(s=s.concat(["INDEX",r])),this.handleLog({type:"request",data:s.join(" ")})}return this.handleLog({type:"transaction.end"})}},e}(),e.API},e.exports=r()},function(e,t,n){var r,o,a=function(e,t){function n(){this.constructor=e}for(var r in t)i.call(t,r)&&(e[r]=t[r]);return n.prototype=t.prototype,e.prototype=new n,e.__super__=t.prototype,e},i={}.hasOwnProperty,s=[].slice;r=n(3),o=function(e){function t(){return t.__super__.constructor.apply(this,arguments)}return a(t,e),t.prototype.handleMethod=function(){var e,t;return t=arguments[0],e=2<=arguments.length?s.call(arguments,1):[],this.connection[t].apply(this.connection,e)},t.prototype.handleLogging=function(e){return this.handler=e,this.connection.logging.handleLog=function(e){return function(){return e.handleLog.apply(e,arguments)}}(this)},t}(r),e.exports=o},function(e,t){var n,r=[].slice;n=function(){function e(e){this.connection=e,this.proxyAPIMethods()}return e.prototype.proxyAPIMethods=function(e){var t,n,o;return null==e&&(e=[]),n=function(){var e,n;e=this.connection,n=[];for(t in e)o=e[t],"function"==typeof o&&n.push(t);return n}.call(this),n.forEach(function(e){return function(t){if("index"!==t)return e[t]=function(){return e.handleMethod.apply(e,[t].concat(r.call(arguments)))}}}(this))},e.prototype.index=function(e,t){return this.connection.createNamespaceForIndex(t,e,this)},e.prototype.handleLog=function(e){var t,n;if(this.handler){if(this.handler!==console)return this.handler(e);switch(n=e.type,t=e.data,n){case"transaction.start":return console.groupCollapsed(t);case"request":return console.log(t);case"transaction.end":return console.groupEnd()}}},e.prototype.proxyObjectStoresNamespace=function(e){return this.connection.createNamespaceForObjectStores(e,this)},e}(),e.exports=n},function(e,t,n){var r,o,a,i,s=function(e,t){return function(){return e.apply(t,arguments)}},u=function(e,t){function n(){this.constructor=e}for(var r in t)c.call(t,r)&&(e[r]=t[r]);return n.prototype=t.prototype,e.prototype=new n,e.__super__=t.prototype,e},c={}.hasOwnProperty,l=[].slice;r=n(3),o=n(5),i=n(6),a=function(e){function t(){this.handleMessage=s(this.handleMessage,this),t.__super__.constructor.apply(this,arguments),this.promises={},this.messages=[],this.id=1,this.spawnWorker()}return u(t,e),t.prototype.spawnWorker=function(){var e,t,n,r,a;return a=this.connection,r=a.name,n=a.migrations,e=new Blob([o,i]),t=window.URL.createObjectURL(e),this.worker=new Worker(t),this.worker.onmessage=this.handleMessage,this.worker.postMessage({method:"init",args:{name:r,migrations:n}}),console.info("Ndex: Worker for “"+r+"” spawned at "+t)},t.prototype.handleLogging=function(e){return this.handler=e,this.worker.postMessage({method:"handleLogging"})},t.prototype.createPromiseForId=function(e){return new Promise(function(t){return function(n,r){return t.promises[e]={id:e,resolve:n,reject:r}}}(this))},t.prototype.handleMethod=function(){var e,t,n,r;return n=arguments[0],e=2<=arguments.length?l.call(arguments,1):[],t=this.id++,r=this.createPromiseForId(t),this.messages.length||this.schedulePostMessage(),this.messages.push({id:t,method:n,args:e}),r},t.prototype.schedulePostMessage=function(){return setTimeout(function(e){return function(){var t;return t=e.messages.splice(0),e.worker.postMessage(t)}}(this),0)},t.prototype.handleMessage=function(e){var t,n,r,o,a,i,s;return a=e.data,n=a.id,s=a.resolve,i=a.reject,r=a.method,t=a.args,r?this[r](t):(o=this.promises[n],delete this.promises[n],"resolve"in e.data?o.resolve(s):o.reject(new Error(i)))},t}(r),e.exports=a},function(e,t){e.exports="var factory,\n  slice = [].slice;\n\nfactory = function() {\n  var Connection;\n  Connection = {};\n  Connection.API = (function() {\n    API.prototype.CONNECTION_TIMEOUT = 5000;\n\n    API.prototype.REQUEST_TIMEOUT = 5000;\n\n    function API(name1, migrations1, options1) {\n      this.name = name1;\n      this.migrations = migrations1;\n      this.options = options1 != null ? options1 : {};\n      this.database = null;\n      this.queue = {};\n      this.logging = new Connection.Logging;\n    }\n\n    API.prototype.parseMigrations = function(migrations) {\n      var keys, version;\n      if (version = migrations.version) {\n        this.version = version;\n        delete migrations.version;\n      }\n      keys = Object.keys(migrations).sort();\n      return keys.map((function(_this) {\n        return function(key) {\n          var actions, title, titleMatches;\n          version = parseInt(key);\n          titleMatches = key.match(/_(.+)/);\n          title = titleMatches ? titleMatches[1].replace(/(\\w)([A-Z])/g, function($1, $2, $3) {\n            return $2 + \" \" + ($3.toLowerCase());\n          }) : '';\n          actions = migrations[key] || [];\n          if (!Array.isArray(actions)) {\n            actions = [actions];\n          }\n          return {\n            version: version,\n            title: title,\n            actions: actions,\n            key: key\n          };\n        };\n      })(this));\n    };\n\n    API.prototype.deleteDatabase = function() {\n      return new Promise((function(_this) {\n        return function(resolve) {\n          var request;\n          if (!_this.database) {\n            return resolve();\n          }\n          _this.close();\n          request = indexedDB.deleteDatabase(_this.database.name);\n          return request.onsuccess = function(e) {\n            return setTimeout((function() {\n              return resolve();\n            }), 0);\n          };\n        };\n      })(this));\n    };\n\n    API.prototype.open = function(arg) {\n      var withoutVersion;\n      withoutVersion = (arg != null ? arg : {}).withoutVersion;\n      if (this.dbPromise) {\n        return this.dbPromise;\n      }\n      return this.dbPromise = new Promise((function(_this) {\n        return function(resolve, reject) {\n          var connectionTimeout, e, migrations, ref, request, version;\n          if (!self.indexedDB) {\n            return reject('indexedDB isn’t supported');\n          }\n          migrations = _this.parseMigrations(_this.migrations);\n          try {\n            version = withoutVersion ? void 0 : _this.version || migrations.length + 1;\n            request = indexedDB.open(_this.name, version);\n            connectionTimeout = (ref = _this.options.connectionTimeout) != null ? ref : _this.CONNECTION_TIMEOUT;\n            if ((connectionTimeout != null) && connectionTimeout > -1) {\n              request.__timeout = setTimeout(function() {\n                if (request.__handled) {\n                  return;\n                }\n                request.__timedout = true;\n                return reject(new Error('Connection timed out'));\n              }, connectionTimeout);\n            }\n          } catch (error1) {\n            e = error1;\n            clearTimeout(request.__timeout);\n            if (request.__timedout) {\n              return;\n            }\n            request.__handled = true;\n            return reject(e.message || e.name);\n          }\n          request.onupgradeneeded = function(e) {\n            var action, db, j, l, len, len1, migration, migrationTransaction, name1, ref1, results1, transaction;\n            clearTimeout(request.__timeout);\n            if (request.__timedout) {\n              return;\n            }\n            request.__handled = true;\n            db = e.target.result;\n            transaction = e.target.transaction;\n            migrationTransaction = new Connection.Migration(db, transaction);\n            migrationTransaction.createObjectStore('migrations', {\n              keyPath: 'version'\n            });\n            results1 = [];\n            for (j = 0, len = migrations.length; j < len; j++) {\n              migration = migrations[j];\n              ref1 = migration.actions;\n              for (l = 0, len1 = ref1.length; l < len1; l++) {\n                action = ref1[l];\n                if (typeof migrationTransaction[name1 = action.type] === \"function\") {\n                  migrationTransaction[name1].apply(migrationTransaction, action.args);\n                }\n              }\n              results1.push(transaction.objectStore('migrations').put(migration));\n            }\n            return results1;\n          };\n          request.onsuccess = function(e) {\n            var db, objectStoreNames;\n            clearTimeout(request.__timeout);\n            if (request.__timedout) {\n              return;\n            }\n            request.__handled = true;\n            db = e.target.result;\n            objectStoreNames = [].slice.call(db.objectStoreNames);\n            _this.createNamespaceForObjectStores(objectStoreNames);\n            db.onversionchange = function() {\n              return _this.close();\n            };\n            _this.database = db;\n            return resolve(objectStoreNames);\n          };\n          return request.onerror = function(e) {\n            clearTimeout(request.__timeout);\n            if (request.__timedout) {\n              return;\n            }\n            request.__handled = true;\n            if (!withoutVersion && request.error.name === 'VersionError') {\n              _this.close();\n              return _this.open({\n                withoutVersion: true\n              }).then(resolve)[\"catch\"](reject);\n            }\n            return reject(request.error.message || request.error.name);\n          };\n        };\n      })(this));\n    };\n\n    API.prototype.close = function() {\n      if (this.dbPromise) {\n        delete this.dbPromise;\n      }\n      if (this.database) {\n        return this.database.close();\n      }\n    };\n\n    API.prototype.get = function(objectStoreName, key, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          if (Array.isArray(key)) {\n            return Promise.all(key.map(function(k) {\n              return _this.get(objectStoreName, k);\n            })).then(resolve)[\"catch\"](reject);\n          } else {\n            return _this.enqueue('read', objectStoreName, reject, function(transaction) {\n              var params;\n              _this.logging.addRequest(transaction, 'get', objectStoreName, indexName, {\n                key: key\n              });\n              params = {\n                method: 'get',\n                args: key,\n                transaction: transaction,\n                reject: reject,\n                objectStoreName: objectStoreName,\n                indexName: indexName\n              };\n              return _this.createRequest(params, function(e) {\n                var value;\n                value = e.target.result;\n                if (value === void 0) {\n                  value = null;\n                }\n                return resolve(value);\n              });\n            });\n          }\n        };\n      })(this));\n    };\n\n    API.prototype.getFirst = function(objectStoreName, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('read', objectStoreName, reject, function(transaction) {\n            var params;\n            _this.logging.addRequest(transaction, 'getFirst', objectStoreName, indexName);\n            params = {\n              method: 'openCursor',\n              transaction: transaction,\n              reject: reject,\n              objectStoreName: objectStoreName,\n              indexName: indexName\n            };\n            return _this.createRequest(params, function(e) {\n              var cursor, objectStore, request, value;\n              request = e.target;\n              objectStore = request.source;\n              if (!(cursor = request.result)) {\n                return resolve(null);\n              }\n              value = cursor.value;\n              if (!objectStore.keyPath) {\n                value._key = cursor.key;\n              }\n              return resolve(value);\n            });\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.getAll = function(objectStoreName, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('read', objectStoreName, reject, function(transaction) {\n            var params, results;\n            _this.logging.addRequest(transaction, 'getAll', objectStoreName, indexName);\n            results = [];\n            params = {\n              method: 'openCursor',\n              transaction: transaction,\n              reject: reject,\n              objectStoreName: objectStoreName,\n              indexName: indexName\n            };\n            return _this.createRequest(params, function(e) {\n              var cursor, objectStore, request, value;\n              request = e.target;\n              objectStore = request.source;\n              if (!(cursor = e.target.result)) {\n                return resolve(results);\n              }\n              value = cursor.value;\n              if (!objectStore.keyPath) {\n                value._key = cursor.key;\n              }\n              results.push(value);\n              return cursor[\"continue\"]();\n            });\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.count = function(objectStoreName, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('read', objectStoreName, reject, function(transaction) {\n            var params;\n            _this.logging.addRequest(transaction, 'count', objectStoreName, indexName);\n            params = {\n              method: 'count',\n              transaction: transaction,\n              reject: reject,\n              objectStoreName: objectStoreName,\n              indexName: indexName\n            };\n            return _this.createRequest(params, function(e) {\n              var value;\n              value = e.target.result;\n              if (!value) {\n                value = 0;\n              }\n              return resolve(value);\n            });\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.add = function(objectStoreName, key, data) {\n      var ref;\n      if (data === void 0) {\n        ref = [null, key], key = ref[0], data = ref[1];\n      }\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          if (!key && Array.isArray(data)) {\n            return Promise.all(data.map(function(d) {\n              return _this.add(objectStoreName, d);\n            })).then(resolve)[\"catch\"](reject);\n          } else if (key && Array.isArray(key) && Array.isArray(data)) {\n            return Promise.all(key.map(function(key, i) {\n              return _this.add(objectStoreName, key, data[i]);\n            })).then(resolve)[\"catch\"](reject);\n          } else {\n            return _this.enqueue('write', objectStoreName, reject, function(transaction) {\n              var args, params;\n              _this.logging.addRequest(transaction, 'add', objectStoreName, null, {\n                key: key,\n                data: data\n              });\n              args = key ? [data, key] : [data];\n              params = {\n                method: 'put',\n                args: args,\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                reject: reject\n              };\n              return _this.createRequest(params, function(e) {\n                data._key = e.target.result;\n                return resolve(data);\n              });\n            });\n          }\n        };\n      })(this));\n    };\n\n    API.prototype.update = function(objectStoreName, key, value) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('write', objectStoreName, reject, function(transaction) {\n            var params;\n            _this.logging.addRequest(transaction, 'update', objectStoreName, null, {\n              key: key,\n              data: value\n            });\n            params = {\n              method: 'get',\n              args: key,\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              reject: reject\n            };\n            return _this.createRequest(params, function(e) {\n              var args, data, deepUpdate, hasKeyPath, keyPath, objectStore, request;\n              request = e.target;\n              objectStore = request.source;\n              keyPath = objectStore.keyPath;\n              hasKeyPath = !!keyPath;\n              data = request.result;\n              if (data === void 0) {\n                data = value;\n                if (hasKeyPath) {\n                  data[keyPath] = key;\n                }\n              } else {\n                deepUpdate = function(o, root) {\n                  var k, results1, v;\n                  results1 = [];\n                  for (k in o) {\n                    v = o[k];\n                    if (typeof v === 'object') {\n                      deepUpdate(v, root[k]);\n                      continue;\n                    }\n                    results1.push(root[k] = v);\n                  }\n                  return results1;\n                };\n                deepUpdate(value, data);\n              }\n              args = hasKeyPath ? [data] : [data, key];\n              params = {\n                method: 'put',\n                args: args,\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                reject: reject\n              };\n              return _this.createRequest(params, function(e) {\n                return resolve(data);\n              });\n            });\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.increment = function(objectStoreName, key, value, decrement) {\n      if (value == null) {\n        value = 1;\n      }\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('write', objectStoreName, reject, function(transaction) {\n            var params;\n            _this.logging.addRequest(transaction, (decrement ? 'decrement' : 'increment'), objectStoreName, null, {\n              key: key,\n              data: value\n            });\n            params = {\n              method: 'get',\n              args: key,\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              reject: reject\n            };\n            return _this.createRequest(params, function(e) {\n              var args, data, deepIncrement, hasKeyPath, keyPath, objectStore, request;\n              request = e.target;\n              objectStore = request.source;\n              keyPath = objectStore.keyPath;\n              hasKeyPath = !!keyPath;\n              data = request.result;\n              if (hasKeyPath) {\n                deepIncrement = function(o, root) {\n                  var k, results1, v;\n                  results1 = [];\n                  for (k in o) {\n                    v = o[k];\n                    if (typeof v === 'object') {\n                      deepIncrement(v, root[k]);\n                      continue;\n                    }\n                    root[k] || (root[k] = 0);\n                    results1.push(root[k] += decrement ? -v : v);\n                  }\n                  return results1;\n                };\n                deepIncrement(value, data);\n              } else {\n                data || (data = 0);\n                data += decrement ? -value : value;\n              }\n              args = hasKeyPath ? [data] : [data, key];\n              params = {\n                method: 'put',\n                args: args,\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                reject: reject\n              };\n              return _this.createRequest(params, function(e) {\n                return resolve(data);\n              });\n            });\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.decrement = function(objectStoreName, key, value) {\n      return this.increment(objectStoreName, key, value, true);\n    };\n\n    API.prototype[\"delete\"] = function(objectStoreName, key) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          if (Array.isArray(key)) {\n            return Promise.all(key.map(function(k) {\n              return _this[\"delete\"](objectStoreName, k);\n            })).then(resolve)[\"catch\"](reject);\n          } else {\n            return _this.enqueue('write', objectStoreName, reject, function(transaction) {\n              var params;\n              _this.logging.addRequest(transaction, 'delete', objectStoreName, null, {\n                key: key\n              });\n              params = {\n                method: 'delete',\n                args: key,\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                reject: reject\n              };\n              return _this.createRequest(params, function(e) {\n                return resolve(key);\n              });\n            });\n          }\n        };\n      })(this));\n    };\n\n    API.prototype.deleteWhere = function(objectStoreName, predicates, indexName) {\n      predicates.remove = true;\n      return this.where(objectStoreName, predicates, indexName);\n    };\n\n    API.prototype.clear = function(objectStoreName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('write', objectStoreName, reject, function(transaction) {\n            var params;\n            _this.logging.addRequest(transaction, 'clear', objectStoreName);\n            params = {\n              method: 'clear',\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              reject: reject\n            };\n            return _this.createRequest(params, function(e) {\n              return resolve();\n            });\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.clearAll = function() {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var objectStoreNames;\n          objectStoreNames = slice.call(_this.database.objectStoreNames);\n          objectStoreNames = objectStoreNames.filter(function(objectStoreName) {\n            return objectStoreName !== 'migrations';\n          });\n          return Promise.all(objectStoreNames.map(function(objectStoreName) {\n            return _this.clear(objectStoreName);\n          })).then(resolve)[\"catch\"](reject);\n        };\n      })(this));\n    };\n\n    API.prototype.reset = function(objectStoreName, key, data) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.clear(objectStoreName).then(function() {\n            return _this.add(objectStoreName, key, data).then(resolve)[\"catch\"](reject);\n          })[\"catch\"](reject);\n        };\n      })(this));\n    };\n\n    API.prototype.index = function(objectStoreName, indexName) {\n      return this.createNamespaceForIndex(indexName, objectStoreName);\n    };\n\n    API.prototype.where = function(objectStoreName, predicates, indexName) {\n      var readWrite;\n      readWrite = predicates.remove ? 'write' : 'read';\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue(readWrite, objectStoreName, reject, function(transaction) {\n            var args, bound, bounds, contains, count, eq, eqIsArray, exact, except, gt, gteq, hasValues, isEquivalent, isInclusive, isLowerBound, k, knownUniques, limit, lower, lt, lteq, offset, only, order, params, range, ref, remove, results, uniq, uniques, upper, v;\n            _this.logging.addRequest(transaction, 'where', objectStoreName, indexName, {\n              data: predicates\n            });\n            lt = predicates.lt, lteq = predicates.lteq, gt = predicates.gt, gteq = predicates.gteq, eq = predicates.eq, limit = predicates.limit, offset = predicates.offset, only = predicates.only, contains = predicates.contains, except = predicates.except, uniq = predicates.uniq, order = predicates.order, remove = predicates.remove;\n            uniques = Array.isArray(uniq) ? uniq : uniq ? [uniq] : [];\n            order = order === 'desc' ? 'prev' : 'next';\n            bounds = {};\n            ref = {\n              lt: lt,\n              lteq: lteq,\n              gt: gt,\n              gteq: gteq,\n              eq: eq\n            };\n            for (k in ref) {\n              v = ref[k];\n              if (v === void 0) {\n                continue;\n              }\n              isInclusive = k === 'gteq' || k === 'lteq';\n              isEquivalent = k === 'eq';\n              isLowerBound = k === 'gt' || k === 'gteq';\n              bound = isEquivalent ? 'exact' : isLowerBound ? 'lower' : 'upper';\n              bounds[bound] = {\n                value: v,\n                open: !isInclusive\n              };\n            }\n            range = null;\n            eqIsArray = false;\n            lower = bounds.lower, upper = bounds.upper, exact = bounds.exact;\n            if (exact) {\n              if (eqIsArray = Array.isArray(eq)) {\n                eq.sort();\n                lower = {\n                  value: eq[0],\n                  open: false\n                };\n                upper = {\n                  value: eq[eq.length - 1],\n                  open: false\n                };\n                range = IDBKeyRange.bound(lower.value, upper.value, lower.open, upper.open);\n              } else {\n                range = IDBKeyRange.only(exact.value);\n              }\n            } else if (lower && upper) {\n              range = IDBKeyRange.bound(lower.value, upper.value, lower.open, upper.open);\n            } else if (lower) {\n              range = IDBKeyRange.lowerBound(lower.value, lower.open);\n            } else if (upper) {\n              range = IDBKeyRange.upperBound(upper.value, upper.open);\n            }\n            results = [];\n            count = 0;\n            knownUniques = {};\n            hasValues = function(object, k, v) {\n              if (!Array.isArray(v)) {\n                v = [v];\n              }\n              return v.indexOf(object[k]) !== -1;\n            };\n            args = range ? [range, order] : void 0;\n            params = {\n              method: 'openCursor',\n              args: args,\n              transaction: transaction,\n              reject: reject,\n              objectStoreName: objectStoreName,\n              indexName: indexName\n            };\n            return _this.createRequest(params, function(e) {\n              var a, cursor, j, knownValues, len, objectStore, request, value;\n              request = e.target;\n              objectStore = request.source;\n              if (!(cursor = e.target.result)) {\n                return resolve(results);\n              }\n              value = cursor.value;\n              if (eqIsArray) {\n                only || (only = {});\n                only[objectStore.keyPath] = eq;\n              }\n              for (k in only) {\n                v = only[k];\n                if (!hasValues(value, k, v)) {\n                  return cursor[\"continue\"]();\n                }\n              }\n              for (k in contains) {\n                v = contains[k];\n                if (!Array.isArray(v)) {\n                  v = [v];\n                }\n                a = value[k];\n                if (!Array.isArray(a)) {\n                  a = [a];\n                }\n                if (!_this.intersect(a, v).length) {\n                  return cursor[\"continue\"]();\n                }\n              }\n              for (k in except) {\n                v = except[k];\n                if (hasValues(value, k, v)) {\n                  return cursor[\"continue\"]();\n                }\n              }\n              for (j = 0, len = uniques.length; j < len; j++) {\n                k = uniques[j];\n                knownValues = knownUniques[k] || (knownUniques[k] = []);\n                if (knownValues.indexOf(value[k]) !== -1) {\n                  return cursor[\"continue\"]();\n                }\n                knownUniques[k].push(value[k]);\n              }\n              count++;\n              if (offset && count <= offset) {\n                return cursor[\"continue\"]();\n              }\n              results.push(value);\n              if (remove) {\n                cursor[\"delete\"]();\n              }\n              if (limit) {\n                if (typeof limit === 'function' && limit(results)) {\n                  return resolve(results);\n                } else if (limit === results.length) {\n                  return resolve(results);\n                }\n              }\n              return cursor[\"continue\"]();\n            });\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.getMethodsForObjectStore = function() {\n      return this._getMethodsForObjectStore || (this._getMethodsForObjectStore = ['get', 'getFirst', 'getAll', 'count', 'add', 'update', 'increment', 'decrement', 'delete', 'deleteWhere', 'clear', 'reset', 'index', 'where']);\n    };\n\n    API.prototype.getMethodsForIndex = function() {\n      return this._getMethodsForIndex || (this._getMethodsForIndex = ['get', 'getFirst', 'getAll', 'count', 'where', 'deleteWhere']);\n    };\n\n    API.prototype.createNamespaceForObjectStores = function(objectStoreNames, context) {\n      var j, len, objectStoreName, results1;\n      if (objectStoreNames == null) {\n        objectStoreNames = [];\n      }\n      if (context == null) {\n        context = this;\n      }\n      results1 = [];\n      for (j = 0, len = objectStoreNames.length; j < len; j++) {\n        objectStoreName = objectStoreNames[j];\n        if (objectStoreName === 'migrations') {\n          continue;\n        }\n        results1.push(this.createNamespaceForObjectStore(objectStoreName, context));\n      }\n      return results1;\n    };\n\n    API.prototype.createNamespaceForObjectStore = function(objectStoreName, context) {\n      var namespace;\n      if (context == null) {\n        context = this;\n      }\n      namespace = context[objectStoreName] = {};\n      this.getMethodsForObjectStore().forEach((function(_this) {\n        return function(method) {\n          return namespace[method] = function() {\n            return context[method].apply(context, [objectStoreName].concat(slice.call(arguments)));\n          };\n        };\n      })(this));\n      return namespace;\n    };\n\n    API.prototype.createNamespaceForIndex = function(indexName, objectStoreName, context) {\n      var namespace;\n      if (context == null) {\n        context = this;\n      }\n      namespace = {};\n      this.getMethodsForIndex().forEach((function(_this) {\n        return function(method) {\n          return namespace[method] = function() {\n            return context[method].apply(context, [objectStoreName].concat(slice.call(arguments), [indexName]));\n          };\n        };\n      })(this));\n      return namespace;\n    };\n\n    API.prototype.getObjectStore = function(arg) {\n      var indexName, objectStore, objectStoreName, transaction;\n      transaction = arg.transaction, objectStoreName = arg.objectStoreName, indexName = arg.indexName;\n      objectStore = transaction.objectStore(objectStoreName);\n      if (indexName) {\n        return objectStore.index(indexName);\n      } else {\n        return objectStore;\n      }\n    };\n\n    API.prototype.createRequest = function(arg, callback) {\n      var args, indexName, method, objectStore, objectStoreName, ref, reject, request, requestTimeout, transaction;\n      method = arg.method, args = arg.args, transaction = arg.transaction, objectStoreName = arg.objectStoreName, indexName = arg.indexName, reject = arg.reject;\n      objectStore = transaction.objectStore(objectStoreName);\n      if (indexName) {\n        objectStore = objectStore.index(indexName);\n      }\n      if (!Array.isArray(args)) {\n        args = [args];\n      }\n      request = objectStore[method].apply(objectStore, args);\n      requestTimeout = (ref = this.options.requestTimeout) != null ? ref : this.REQUEST_TIMEOUT;\n      if ((requestTimeout != null) && requestTimeout > -1) {\n        request.__timeout = setTimeout(function() {\n          if (request.__handled) {\n            return;\n          }\n          request.__timedout = true;\n          try {\n            return transaction.abort();\n          } catch (error1) {}\n        }, requestTimeout);\n      }\n      request.onsuccess = function(e) {\n        clearTimeout(request.__timeout);\n        if (request.__timedout) {\n          return;\n        }\n        request.__handled = true;\n        return callback(e);\n      };\n      request.onerror = function(e) {\n        clearTimeout(request.__timeout);\n        request.__handled = true;\n        return typeof reject === \"function\" ? reject(request.error) : void 0;\n      };\n      return request;\n    };\n\n    API.prototype.createTransaction = function(mode, objectStoreName, callback) {\n      return this.open().then((function(_this) {\n        return function() {\n          var error, transaction;\n          try {\n            transaction = _this.database.transaction([objectStoreName], mode);\n          } catch (error1) {\n            error = error1;\n          }\n          return callback(transaction);\n        };\n      })(this))[\"catch\"]((function(_this) {\n        return function(err) {\n          throw err;\n        };\n      })(this));\n    };\n\n    API.prototype.intersect = function(a, b) {\n      var ai, bi, result;\n      ai = 0;\n      bi = 0;\n      result = [];\n      while (ai < a.length && bi < b.length) {\n        if (a[ai] < b[bi]) {\n          ai++;\n        } else if (a[ai] > b[bi]) {\n          bi++;\n        } else {\n          result.push(a[ai]);\n          ai++;\n          bi++;\n        }\n      }\n      return result;\n    };\n\n    API.prototype.enqueue = function(readwrite, objectStoreName, reject, callback) {\n      var base, request;\n      (base = this.queue)[objectStoreName] || (base[objectStoreName] = []);\n      request = {\n        readwrite: readwrite,\n        objectStoreName: objectStoreName,\n        reject: reject,\n        callback: callback\n      };\n      if (!this.queue[objectStoreName].length) {\n        this.scheduleTransaction(objectStoreName);\n      }\n      return this.queue[objectStoreName].push(request);\n    };\n\n    API.prototype.scheduleTransaction = function(objectStoreName) {\n      return setTimeout((function(_this) {\n        return function() {\n          var mode, modes, needsWriteMode, requests;\n          requests = _this.queue[objectStoreName].splice(0);\n          modes = requests.map(function(r) {\n            return r.readwrite;\n          });\n          needsWriteMode = modes.some(function(m) {\n            return m === 'write';\n          });\n          mode = needsWriteMode ? 'readwrite' : 'readonly';\n          return _this.createTransaction(mode, objectStoreName, function(transaction) {\n            var err, j, len, request, results1;\n            _this.logging.addTransaction(transaction, objectStoreName);\n            results1 = [];\n            for (j = 0, len = requests.length; j < len; j++) {\n              request = requests[j];\n              try {\n                results1.push(request.callback(transaction));\n              } catch (error1) {\n                err = error1;\n                results1.push(request.reject(err));\n              }\n            }\n            return results1;\n          });\n        };\n      })(this), 0);\n    };\n\n    return API;\n\n  })();\n  Connection.Migration = (function() {\n    function Migration(db1, transaction1) {\n      this.db = db1;\n      this.transaction = transaction1;\n    }\n\n    Migration.prototype.createObjectStore = function(name, options) {\n      if (this.db.objectStoreNames.contains(name)) {\n        return;\n      }\n      return this.db.createObjectStore(name, options);\n    };\n\n    Migration.prototype.deleteObjectStore = function(name) {\n      if (!this.db.objectStoreNames.contains(name)) {\n        return;\n      }\n      return this.db.deleteObjectStore(name);\n    };\n\n    Migration.prototype.createIndex = function(objectStoreName, indexName, keyPath, options) {\n      var objectStore;\n      objectStore = this.transaction.objectStore(objectStoreName);\n      if (objectStore && objectStore.indexNames.contains(indexName)) {\n        return;\n      }\n      return objectStore.createIndex(indexName, keyPath, options);\n    };\n\n    Migration.prototype.deleteIndex = function(objectStoreName, indexName) {\n      var objectStore;\n      objectStore = this.transaction.objectStore(objectStoreName);\n      if (!(objectStore && objectStore.indexNames.contains(indexName))) {\n        return;\n      }\n      return objectStore.deleteIndex(indexName);\n    };\n\n    return Migration;\n\n  })();\n  Connection.Logging = (function() {\n    function Logging() {\n      this.queues = [];\n    }\n\n    Logging.prototype.addTransaction = function(transaction, objectStoreNames) {\n      var callback;\n      if (!(transaction && this.handleLog)) {\n        return;\n      }\n      this.queues.push({\n        transaction: transaction,\n        objectStoreNames: objectStoreNames,\n        requests: [],\n        start: Date.now()\n      });\n      callback = (function(_this) {\n        return function(e) {\n          return _this.logTransaction(e.target);\n        };\n      })(this);\n      transaction.onabort = callback;\n      transaction.onerror = callback;\n      return transaction.oncomplete = callback;\n    };\n\n    Logging.prototype.addRequest = function(transaction, method, objectStoreName, indexName, data) {\n      var queue;\n      if (!(transaction && this.handleLog)) {\n        return;\n      }\n      queue = this.queues.filter(function(q) {\n        return q.transaction === transaction;\n      })[0];\n      if (!queue) {\n        return;\n      }\n      return queue.requests.push({\n        method: method,\n        objectStoreName: objectStoreName,\n        indexName: indexName,\n        data: data\n      });\n    };\n\n    Logging.prototype.logTransaction = function(transaction) {\n      var data, end, indexName, j, key, len, logs, method, mode, objectStoreName, queue, ref, ref1, request, requestsLenght, time;\n      if (!(transaction && this.handleLog)) {\n        return;\n      }\n      queue = this.queues.filter(function(q) {\n        return q.transaction === transaction;\n      })[0];\n      if (!queue) {\n        return;\n      }\n      mode = queue.transaction.mode === 'readwrite' ? 'write' : 'read ';\n      requestsLenght = queue.requests.length;\n      end = Date.now();\n      time = end - queue.start;\n      this.handleLog({\n        type: 'transaction.start',\n        data: \"Ndex: \" + mode + \" \" + queue.objectStoreNames + \" \" + time + \"ms (\" + requestsLenght + \" request\" + (requestsLenght > 1 ? 's' : '') + \")\"\n      });\n      ref = queue.requests;\n      for (j = 0, len = ref.length; j < len; j++) {\n        request = ref[j];\n        method = request.method, objectStoreName = request.objectStoreName, indexName = request.indexName, data = request.data;\n        if (data) {\n          ref1 = data, key = ref1.key, data = ref1.data;\n        }\n        logs = [];\n        switch (method) {\n          case 'get':\n            logs = ['GET', key, 'FROM', objectStoreName];\n            break;\n          case 'getFirst':\n            logs = ['GET FIRST', key, 'FROM', objectStoreName];\n            break;\n          case 'getAll':\n            logs = ['GET ALL', 'FROM', objectStoreName];\n            break;\n          case 'count':\n            logs = ['COUNT', 'FROM', objectStoreName];\n            break;\n          case 'add':\n            logs = ['ADD', JSON.stringify(data), 'TO', objectStoreName];\n            if (key) {\n              logs = logs.concat(['WITH KEY', key]);\n            }\n            break;\n          case 'update':\n            logs = ['UPDATE', key, 'FROM', objectStoreName, 'SET', JSON.stringify(data)];\n            break;\n          case 'increment':\n            if (typeof data === 'object') {\n              data = JSON.stringify(data);\n            }\n            logs = ['INCREMENT', data, 'TO KEY', key, 'FROM', objectStoreName];\n            break;\n          case 'decrement':\n            if (typeof data === 'object') {\n              data = JSON.stringify(data);\n            }\n            logs = ['DECREMENT', data, 'TO KEY', key, 'FROM', objectStoreName];\n            break;\n          case 'delete':\n            logs = ['DELETE', key, 'FROM', objectStoreName];\n            break;\n          case 'clear':\n            logs = ['CLEAR', objectStoreName];\n            break;\n          case 'where':\n            if (typeof data.limit === 'function') {\n              data.limit = '[FUNCTION]';\n            }\n            logs = ['WHERE', JSON.stringify(data), 'FROM', objectStoreName];\n        }\n        if (indexName) {\n          logs = logs.concat(['INDEX', indexName]);\n        }\n        this.handleLog({\n          type: 'request',\n          data: logs.join(' ')\n        });\n      }\n      return this.handleLog({\n        type: 'transaction.end'\n      });\n    };\n\n    return Logging;\n\n  })();\n  return Connection.API;\n};\n\nif (typeof exports !== 'undefined') {\n  module.exports = factory();\n} else {\n  this.Connection = factory();\n}\n";
},function(e,t){e.exports="var handleLogging, init;\n\ninit = function(arg) {\n  var migrations, name;\n  name = arg.name, migrations = arg.migrations;\n  return this.connection = new Connection(name, migrations);\n};\n\nhandleLogging = function() {\n  return this.connection.logging.handleLog = function(args) {\n    return postMessage({\n      method: 'handleLog',\n      args: args\n    });\n  };\n};\n\nself.onmessage = (function(_this) {\n  return function(e) {\n    var data;\n    data = e.data;\n    if (!Array.isArray(data)) {\n      data = [data];\n    }\n    return data.forEach(function(datum) {\n      var args, id, method;\n      id = datum.id, method = datum.method, args = datum.args;\n      if (typeof _this[method] === 'function') {\n        return _this[method](args);\n      }\n      return _this.connection[method].apply(_this.connection, args).then(function(data) {\n        return postMessage({\n          id: id,\n          resolve: data\n        });\n      })[\"catch\"](function(data) {\n        return postMessage({\n          id: id,\n          reject: data\n        });\n      });\n    });\n  };\n})(this);\n"}])});