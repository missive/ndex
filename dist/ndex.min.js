!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.Ndex=t():e.Ndex=t()}(this,function(){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={exports:{},id:r,loaded:!1};return e[r].call(o.exports,o,o.exports,t),o.loaded=!0,o.exports}var n={};return t.m=e,t.c=n,t.p="",t(0)}([function(e,t,n){var r,o,a,i;o=n(1),r=n(2),i=n(4),a=function(){function e(){this.connections={}}return e.prototype.connect=function(e,t,n){return null==n&&(n=null),new Promise(function(a){return function(s,u){var c;if(!n){if(c=a.connections[e])return u(new Error("Already connected to “"+e+"”"));c=new o(e,t),n=a.connections[e]=a.getAdapter(c)}return n.handleMethod("open").then(function(e){return n.proxyObjectStoresNamespace(e),s(n)}).catch(function(t){return n instanceof i?(n=a.connections[e]=new r(c),console.info("Ndex: Fallbacking to BrowserAdapter for “"+e+"” because “"+t+"”"),s(a.connect(null,null,n))):u("Ndex: "+t)})}}(this))},e.prototype.getAdapter=function(e){var t;return new(t=this.getAdapterClass())(e)},e.prototype.getAdapterClass=function(){return this.workersAreSupported()?i:r},e.prototype.workersAreSupported=function(e){return null==e&&(e=window),null!=this._workersAreSupported?this._workersAreSupported:this._workersAreSupported="Worker"in e},e}(),e.exports=new a},function(e,t,n){var r,o=[].slice;r=function(){var e;return e={},e.API=function(){function t(t,n){this.name=t,this.migrations=n,this.database=null,this.queue={},this.logging=new e.Logging}return t.prototype.CONNECTION_TIMEOUT=3e3,t.prototype.REQUEST_TIMEOUT=3e3,t.prototype.parseMigrations=function(e){var t,n;return(n=e.version)&&(this.version=n,delete e.version),t=Object.keys(e).sort(),t.map(function(t){return function(t){var r,o,a;return n=parseInt(t),a=t.match(/_(.+)/),o=a?a[1].replace(/(\w)([A-Z])/g,function(e,t,n){return t+" "+n.toLowerCase()}):"",r=e[t]||[],Array.isArray(r)||(r=[r]),{version:n,title:o,actions:r,key:t}}}(this))},t.prototype.deleteDatabase=function(){return new Promise(function(e){return function(t){var n;return e.database?(e.close(),n=indexedDB.deleteDatabase(e.database.name),n.onsuccess=function(e){return setTimeout(function(){return t()},0)}):t()}}(this))},t.prototype.open=function(){return this.dbPromise?this.dbPromise:this.dbPromise=new Promise(function(t){return function(n,r){var o,a,i;if(!self.indexedDB)return r("indexedDB isn’t supported");a=t.parseMigrations(t.migrations);try{i=indexedDB.open(t.name,t.version||a.length+1),null!=t.CONNECTION_TIMEOUT&&t.CONNECTION_TIMEOUT>-1&&(i.__timeout=setTimeout(function(){return i.__timedout=!0,r(new Error("Connection timed out"))},t.CONNECTION_TIMEOUT))}catch(e){return o=e,clearTimeout(i.__timeout),r(o.message||o.name)}return i.onupgradeneeded=function(t){var n,r,o,s,u,c,l,d,m,f,p,h;if(clearTimeout(i.__timeout),!i.__timedout){for(r=t.target.result,h=t.target.transaction,d=new e.Migration(r,h),d.createObjectStore("migrations",{keyPath:"version"}),p=[],o=0,u=a.length;o<u;o++){for(l=a[o],f=l.actions,s=0,c=f.length;s<c;s++)n=f[s],"function"==typeof d[m=n.type]&&d[m].apply(d,n.args);p.push(h.objectStore("migrations").put(l))}return p}},i.onsuccess=function(e){var r,o;if(clearTimeout(i.__timeout),!i.__timedout)return r=e.target.result,o=[].slice.call(r.objectStoreNames),t.createNamespaceForObjectStores(o),r.onversionchange=function(){return t.close()},t.database=r,n(o)},i.onerror=function(e){return r(i.error.message||i.error.name)}}}(this))},t.prototype.close=function(){return new Promise(function(e){return function(t){return e.dbPromise&&delete e.dbPromise,e.database&&e.database.close(),t()}}(this))},t.prototype.get=function(e,t,n){return new Promise(function(r){return function(o,a){var i;return Array.isArray(t)?(i=Promise.all(t.map(function(t){return r.get(e,t)})),i.then(o)):r.enqueue("read",e,function(i){var s;return r.logging.addRequest(i,"get",e,n,{key:t}),s=r.createRequest({transaction:i,objectStoreName:e,indexName:n,reject:a}),s.get(t).onsuccess=function(e){var t;if(clearTimeout(s.__timeout),!s.__timedout)return t=e.target.result,void 0===t&&(t=null),o(t)}})}}(this))},t.prototype.getFirst=function(e,t){return new Promise(function(n){return function(r,o){return n.enqueue("read",e,function(a){var i;return n.logging.addRequest(a,"getFirst",e,t),i=n.createRequest({transaction:a,objectStoreName:e,indexName:t,reject:o}),i.openCursor().onsuccess=function(e){var t,n;if(clearTimeout(i.__timeout),!i.__timedout)return(t=e.target.result)?(n=t.value,i.keyPath||(n._key=t.key),r(n)):r(null)}})}}(this))},t.prototype.getAll=function(e,t){return new Promise(function(n){return function(r,o){return n.enqueue("read",e,function(a){var i,s;return n.logging.addRequest(a,"getAll",e,t),s=[],i=n.createRequest({transaction:a,objectStoreName:e,indexName:t,reject:o}),i.openCursor().onsuccess=function(e){var t,n;if(clearTimeout(i.__timeout),!i.__timedout)return(t=e.target.result)?(n=t.value,i.keyPath||(n._key=t.key),s.push(n),t.continue()):r(s)}})}}(this))},t.prototype.count=function(e,t){return new Promise(function(n){return function(r,o){return n.enqueue("read",e,function(a){var i;return n.logging.addRequest(a,"count",e,t),i=n.createRequest({transaction:a,objectStoreName:e,indexName:t,reject:o}),i.count().onsuccess=function(e){var t;if(clearTimeout(i.__timeout),!i.__timedout)return t=e.target.result,t||(t=0),r(t)}})}}(this))},t.prototype.add=function(e,t,n){var r;return void 0===n&&(r=[null,t],t=r[0],n=r[1]),new Promise(function(r){return function(o,a){var i;return!t&&Array.isArray(n)?(i=Promise.all(n.map(function(t){return r.add(e,t)})),i.then(o)):t&&Array.isArray(t)&&Array.isArray(n)?(i=Promise.all(t.map(function(t,o){return r.add(e,t,n[o])})),i.then(o)):r.enqueue("write",e,function(i){var s,u;return r.logging.addRequest(i,"add",e,null,{key:t,data:n}),s=t?[n,t]:[n],u=r.createRequest({transaction:i,objectStoreName:e,reject:a}),u.put.apply(u,s).onsuccess=function(e){if(clearTimeout(u.__timeout),!u.__timedout)return n._key=e.target.result,o(n)}})}}(this))},t.prototype.update=function(e,t,n){return new Promise(function(r){return function(o,a){return r.enqueue("write",e,function(i){var s;return r.logging.addRequest(i,"update",e,null,{key:t,data:n}),s=r.createRequest({transaction:i,objectStoreName:e,reject:a}),s.get(t).onsuccess=function(u){var c,l,d,m,f,p;if(clearTimeout(s.__timeout),!s.__timedout)return f=u.target.source.keyPath,m=!!f,l=u.target.result,void 0===l?(l=n,m&&(l[f]=t)):(d=function(e,t){var n,r,o;r=[];for(n in e)o=e[n],"object"!=typeof o?r.push(t[n]=o):d(o,t[n]);return r})(n,l),c=m?[l]:[l,t],p=r.createRequest({transaction:i,objectStoreName:e,reject:a}),p.put.apply(p,c).onsuccess=function(){if(clearTimeout(p.__timeout),!p.__timedout)return o(l)}}})}}(this))},t.prototype.increment=function(e,t,n,r){return null==n&&(n=1),new Promise(function(o){return function(a,i){return o.enqueue("write",e,function(s){var u;return o.logging.addRequest(s,r?"decrement":"increment",e,null,{key:t,data:n}),u=o.createRequest({transaction:s,objectStoreName:e,reject:i}),u.get(t).onsuccess=function(c){var l,d,m,f,p,h;if(clearTimeout(u.__timeout),!u.__timedout)return p=c.target.source.keyPath,f=!!p,d=c.target.result,f?(m=function(e,t){var n,o,a;o=[];for(n in e)a=e[n],"object"!=typeof a?(t[n]||(t[n]=0),o.push(t[n]+=r?-a:a)):m(a,t[n]);return o})(n,d):(d||(d=0),d+=r?-n:n),l=f?[d]:[d,t],h=o.createRequest({transaction:s,objectStoreName:e,reject:i}),h.put.apply(h,l).onsuccess=function(){if(clearTimeout(h.__timeout),!h.__timedout)return a(d)}}})}}(this))},t.prototype.decrement=function(e,t,n){return this.increment(e,t,n,!0)},t.prototype.delete=function(e,t){return new Promise(function(n){return function(r,o){var a;return Array.isArray(t)?(a=Promise.all(t.map(function(t){return n.delete(e,t)})),a.then(r)):n.enqueue("write",e,function(a){var i;return n.logging.addRequest(a,"delete",e,null,{key:t}),i=n.createRequest({transaction:a,objectStoreName:e,reject:o}),i.delete(t).onsuccess=function(e){if(clearTimeout(i.__timeout),!i.__timedout)return r(t)}})}}(this))},t.prototype.deleteWhere=function(e,t,n){return t.remove=!0,this.where(e,t,n)},t.prototype.clear=function(e){return new Promise(function(t){return function(n,r){return t.enqueue("write",e,function(o){var a;return t.logging.addRequest(o,"clear",e),a=t.createRequest({transaction:o,objectStoreName:e,reject:r}),a.clear().onsuccess=function(){if(clearTimeout(a.__timeout),!a.__timedout)return n()}})}}(this))},t.prototype.clearAll=function(){return new Promise(function(e){return function(t,n){var r,a;return r=o.call(e.database.objectStoreNames),r=r.filter(function(e){return"migrations"!==e}),a=Promise.all(r.map(function(t){return e.clear(t)})),a.then(t),a.catch(n)}}(this))},t.prototype.reset=function(e,t,n){return new Promise(function(r){return function(o,a){var i;return i=r.clear(e),i.catch(a),i.then(function(){var i;return i=r.add(e,t,n),i.catch(a),i.then(o)})}}(this))},t.prototype.index=function(e,t){return this.createNamespaceForIndex(t,e)},t.prototype.where=function(e,t,n){var r;return r=t.remove?"write":"read",new Promise(function(o){return function(a,i){return o.enqueue(r,e,function(r){var s,u,c,l,d,m,f,p,h,g,y,b,j,v,q,N,_,S,k,x,w,P,T,A,R,I,O,E,M,F,C,L;o.logging.addRequest(r,"where",e,n,{data:t}),k=t.lt,x=t.lteq,h=t.gt,g=t.gteq,d=t.eq,_=t.limit,w=t.offset,P=t.only,c=t.contains,p=t.except,M=t.uniq,T=t.order,I=t.remove,F=Array.isArray(M)?M:M?[M]:[],T="desc"===T?"prev":"next",u={},R={lt:k,lteq:x,gt:h,gteq:g,eq:d};for(q in R)L=R[q],void 0!==L&&(j="gteq"===q||"lteq"===q,b="eq"===q,v="gt"===q||"gteq"===q,s=b?"exact":v?"lower":"upper",u[s]={value:L,open:!j});return A=null,m=!1,S=u.lower,C=u.upper,f=u.exact,f?(m=Array.isArray(d))?(d.sort(),S={value:d[0],open:!1},C={value:d[d.length-1],open:!1},A=IDBKeyRange.bound(S.value,C.value,S.open,C.open)):A=IDBKeyRange.only(f.value):S&&C?A=IDBKeyRange.bound(S.value,C.value,S.open,C.open):S?A=IDBKeyRange.lowerBound(S.value,S.open):C&&(A=IDBKeyRange.upperBound(C.value,C.open)),E=[],l=0,N={},y=function(e,t,n){return Array.isArray(n)||(n=[n]),n.indexOf(e[t])!==-1},O=o.createRequest({transaction:r,objectStoreName:e,indexName:n,reject:i}),O=A?O.openCursor(A,T):O.openCursor(),O.onsuccess=function(e){var t,n,r,i,s,u,f;if(clearTimeout(O.__timeout),!O.__timedout){if(!(n=e.target.result))return a(E);f=n.value,m&&(i=e.target.source.keyPath,P||(P={}),P[i]=d);for(q in P)if(L=P[q],!y(f,q,L))return n.continue();for(q in c)if(L=c[q],Array.isArray(L)||(L=[L]),t=f[q],Array.isArray(t)||(t=[t]),!o.intersect(t,L).length)return n.continue();for(q in p)if(L=p[q],y(f,q,L))return n.continue();for(r=0,u=F.length;r<u;r++){if(q=F[r],s=N[q]||(N[q]=[]),s.indexOf(f[q])!==-1)return n.continue();N[q].push(f[q])}if(l++,w&&l<=w)return n.continue();if(E.push(f),I&&n.delete(),_){if("function"==typeof _&&_(E))return a(E);if(_===E.length)return a(E)}return n.continue()}}})}}(this))},t.prototype.getMethodsForObjectStore=function(){return this._getMethodsForObjectStore||(this._getMethodsForObjectStore=["get","getFirst","getAll","count","add","update","increment","decrement","delete","deleteWhere","clear","reset","index","where"])},t.prototype.getMethodsForIndex=function(){return this._getMethodsForIndex||(this._getMethodsForIndex=["get","getFirst","getAll","count","where","deleteWhere"])},t.prototype.createNamespaceForObjectStores=function(e,t){var n,r,o,a;for(null==e&&(e=[]),null==t&&(t=this),a=[],n=0,r=e.length;n<r;n++)o=e[n],"migrations"!==o&&a.push(this.createNamespaceForObjectStore(o,t));return a},t.prototype.createNamespaceForObjectStore=function(e,t){var n;return null==t&&(t=this),n=t[e]={},this.getMethodsForObjectStore().forEach(function(r){return function(r){return n[r]=function(){return t[r].apply(t,[e].concat(o.call(arguments)))}}}(this)),n},t.prototype.createNamespaceForIndex=function(e,t,n){var r;return null==n&&(n=this),r={},this.getMethodsForIndex().forEach(function(a){return function(a){return r[a]=function(){return n[a].apply(n,[t].concat(o.call(arguments),[e]))}}}(this)),r},t.prototype.createRequest=function(e){var t,n,r,o,a,i;return i=e.transaction,r=e.objectStoreName,t=e.indexName,o=e.reject,n=i.objectStore(r),a=t?n.index(t):n,o&&null!=this.REQUEST_TIMEOUT&&this.REQUEST_TIMEOUT>-1&&(a.__timeout=setTimeout(function(){return a.__timedout=!0,o(new Error("Request timed out"))},this.REQUEST_TIMEOUT)),a},t.prototype.createTransaction=function(e,t,n){return this.open().then(function(r){return function(){var o;return o=r.database.transaction([t],e),n(o)}}(this)).catch(function(e){return function(e){throw e}}(this))},t.prototype.intersect=function(e,t){var n,r,o;for(n=0,r=0,o=[];n<e.length&&r<t.length;)e[n]<t[r]?n++:e[n]>t[r]?r++:(o.push(e[n]),n++,r++);return o},t.prototype.enqueue=function(e,t,n){var r,o;return(r=this.queue)[t]||(r[t]=[]),o={readwrite:e,callback:n},this.queue[t].length||this.scheduleTransaction(t),this.queue[t].push(o)},t.prototype.scheduleTransaction=function(e){return setTimeout(function(t){return function(){var n,r,o,a;return a=t.queue[e].splice(0),r=a.map(function(e){return e.readwrite}),o=r.some(function(e){return"write"===e}),n=o?"readwrite":"readonly",t.createTransaction(n,e,function(n){var r,o,i,s;for(t.logging.addTransaction(n,e),s=[],r=0,o=a.length;r<o;r++)i=a[r],s.push(i.callback(n));return s})}}(this),0)},t}(),e.Migration=function(){function e(e,t){this.db=e,this.transaction=t}return e.prototype.createObjectStore=function(e,t){if(!this.db.objectStoreNames.contains(e))return this.db.createObjectStore(e,t)},e.prototype.deleteObjectStore=function(e){if(this.db.objectStoreNames.contains(e))return this.db.deleteObjectStore(e)},e.prototype.createIndex=function(e,t,n,r){var o;if(o=this.transaction.objectStore(e),!o||!o.indexNames.contains(t))return o.createIndex(t,n,r)},e.prototype.deleteIndex=function(e,t){var n;if(n=this.transaction.objectStore(e),n&&n.indexNames.contains(t))return n.deleteIndex(t)},e}(),e.Logging=function(){function e(){this.queues=[]}return e.prototype.addTransaction=function(e,t){var n;if(this.handleLog)return this.queues.push({transaction:e,objectStoreNames:t,requests:[],start:Date.now()}),n=function(e){return function(t){return e.logTransaction(t.target)}}(this),e.onabort=n,e.onerror=n,e.oncomplete=n},e.prototype.addRequest=function(e,t,n,r,o){var a;if(this.handleLog&&(a=this.queues.filter(function(t){return t.transaction===e})[0]))return a.requests.push({method:t,objectStoreName:n,indexName:r,data:o})},e.prototype.logTransaction=function(e){var t,n,r,o,a,i,s,u,c,l,d,m,f,p,h,g;if(this.handleLog&&(d=this.queues.filter(function(t){return t.transaction===e})[0])){for(c="readwrite"===d.transaction.mode?"write":"read ",h=d.requests.length,n=Date.now(),g=n-d.start,this.handleLog({type:"transaction.start",data:"Ndex: "+c+" "+d.objectStoreNames+" "+g+"ms ("+h+" request"+(h>1?"s":"")+")"}),m=d.requests,o=0,i=m.length;o<i;o++){switch(p=m[o],u=p.method,l=p.objectStoreName,r=p.indexName,t=p.data,t&&(f=t,a=f.key,t=f.data),s=[],u){case"get":s=["GET",a,"FROM",l];break;case"getFirst":s=["GET FIRST",a,"FROM",l];break;case"getAll":s=["GET ALL","FROM",l];break;case"count":s=["COUNT","FROM",l];break;case"add":s=["ADD",JSON.stringify(t),"TO",l],a&&(s=s.concat(["WITH KEY",a]));break;case"update":s=["UPDATE",a,"FROM",l,"SET",JSON.stringify(t)];break;case"increment":"object"==typeof t&&(t=JSON.stringify(t)),s=["INCREMENT",t,"TO KEY",a,"FROM",l];break;case"decrement":"object"==typeof t&&(t=JSON.stringify(t)),s=["DECREMENT",t,"TO KEY",a,"FROM",l];break;case"delete":s=["DELETE",a,"FROM",l];break;case"clear":s=["CLEAR",l];break;case"where":"function"==typeof t.limit&&(t.limit="[FUNCTION]"),s=["WHERE",JSON.stringify(t),"FROM",l]}r&&(s=s.concat(["INDEX",r])),this.handleLog({type:"request",data:s.join(" ")})}return this.handleLog({type:"transaction.end"})}},e}(),e.API},e.exports=r()},function(e,t,n){var r,o,a=function(e,t){function n(){this.constructor=e}for(var r in t)i.call(t,r)&&(e[r]=t[r]);return n.prototype=t.prototype,e.prototype=new n,e.__super__=t.prototype,e},i={}.hasOwnProperty,s=[].slice;r=n(3),o=function(e){function t(){return t.__super__.constructor.apply(this,arguments)}return a(t,e),t.prototype.handleMethod=function(){var e,t;return t=arguments[0],e=2<=arguments.length?s.call(arguments,1):[],this.connection[t].apply(this.connection,e)},t.prototype.handleLogging=function(e){return this.handler=e,this.connection.logging.handleLog=function(e){return function(){return e.handleLog.apply(e,arguments)}}(this)},t}(r),e.exports=o},function(e,t){var n,r=[].slice;n=function(){function e(e){this.connection=e,this.proxyAPIMethods()}return e.prototype.proxyAPIMethods=function(e){var t,n,o;return null==e&&(e=[]),n=function(){var e,n;e=this.connection,n=[];for(t in e)o=e[t],"function"==typeof o&&n.push(t);return n}.call(this),n.forEach(function(e){return function(t){if("index"!==t)return e[t]=function(){return e.handleMethod.apply(e,[t].concat(r.call(arguments)))}}}(this))},e.prototype.index=function(e,t){return this.connection.createNamespaceForIndex(t,e,this)},e.prototype.handleLog=function(e){var t,n;if(this.handler){if(this.handler!==console)return this.handler(e);switch(n=e.type,t=e.data,n){case"transaction.start":return console.groupCollapsed(t);case"request":return console.log(t);case"transaction.end":return console.groupEnd()}}},e.prototype.proxyObjectStoresNamespace=function(e){return this.connection.createNamespaceForObjectStores(e,this)},e}(),e.exports=n},function(e,t,n){var r,o,a,i,s=function(e,t){return function(){return e.apply(t,arguments)}},u=function(e,t){function n(){this.constructor=e}for(var r in t)c.call(t,r)&&(e[r]=t[r]);return n.prototype=t.prototype,e.prototype=new n,e.__super__=t.prototype,e},c={}.hasOwnProperty,l=[].slice;r=n(3),o=n(5),i=n(6),a=function(e){function t(){this.handleMessage=s(this.handleMessage,this),t.__super__.constructor.apply(this,arguments),this.promises={},this.messages=[],this.id=1,this.spawnWorker()}return u(t,e),t.prototype.spawnWorker=function(){var e,t,n,r,a;return a=this.connection,r=a.name,n=a.migrations,e=new Blob([o,i]),t=window.URL.createObjectURL(e),this.worker=new Worker(t),this.worker.onmessage=this.handleMessage,this.worker.postMessage({method:"init",args:{name:r,migrations:n}}),console.info("Ndex: Worker for “"+r+"” spawned at "+t)},t.prototype.handleLogging=function(e){return this.handler=e,this.worker.postMessage({method:"handleLogging"})},t.prototype.createPromiseForId=function(e){return new Promise(function(t){return function(n,r){return t.promises[e]={id:e,resolve:n,reject:r}}}(this))},t.prototype.handleMethod=function(){var e,t,n,r;return n=arguments[0],e=2<=arguments.length?l.call(arguments,1):[],t=this.id++,r=this.createPromiseForId(t),this.messages.length||this.schedulePostMessage(),this.messages.push({id:t,method:n,args:e}),r},t.prototype.schedulePostMessage=function(){return setTimeout(function(e){return function(){var t;return t=e.messages.splice(0),e.worker.postMessage(t)}}(this),0)},t.prototype.handleMessage=function(e){var t,n,r,o,a,i,s;return a=e.data,n=a.id,s=a.resolve,i=a.reject,r=a.method,t=a.args,r?this[r](t):(o=this.promises[n],delete this.promises[n],"resolve"in e.data?o.resolve(s):o.reject(new Error(i)))},t}(r),e.exports=a},function(e,t){e.exports="var factory,\n  slice = [].slice;\n\nfactory = function() {\n  var Connection;\n  Connection = {};\n  Connection.API = (function() {\n    API.prototype.CONNECTION_TIMEOUT = 3000;\n\n    API.prototype.REQUEST_TIMEOUT = 3000;\n\n    function API(name1, migrations1) {\n      this.name = name1;\n      this.migrations = migrations1;\n      this.database = null;\n      this.queue = {};\n      this.logging = new Connection.Logging;\n    }\n\n    API.prototype.parseMigrations = function(migrations) {\n      var keys, version;\n      if (version = migrations.version) {\n        this.version = version;\n        delete migrations.version;\n      }\n      keys = Object.keys(migrations).sort();\n      return keys.map((function(_this) {\n        return function(key) {\n          var actions, title, titleMatches;\n          version = parseInt(key);\n          titleMatches = key.match(/_(.+)/);\n          title = titleMatches ? titleMatches[1].replace(/(\\w)([A-Z])/g, function($1, $2, $3) {\n            return $2 + \" \" + ($3.toLowerCase());\n          }) : '';\n          actions = migrations[key] || [];\n          if (!Array.isArray(actions)) {\n            actions = [actions];\n          }\n          return {\n            version: version,\n            title: title,\n            actions: actions,\n            key: key\n          };\n        };\n      })(this));\n    };\n\n    API.prototype.deleteDatabase = function() {\n      return new Promise((function(_this) {\n        return function(resolve) {\n          var request;\n          if (!_this.database) {\n            return resolve();\n          }\n          _this.close();\n          request = indexedDB.deleteDatabase(_this.database.name);\n          return request.onsuccess = function(e) {\n            return setTimeout((function() {\n              return resolve();\n            }), 0);\n          };\n        };\n      })(this));\n    };\n\n    API.prototype.open = function() {\n      if (this.dbPromise) {\n        return this.dbPromise;\n      }\n      return this.dbPromise = new Promise((function(_this) {\n        return function(resolve, reject) {\n          var e, migrations, request;\n          if (!self.indexedDB) {\n            return reject('indexedDB isn’t supported');\n          }\n          migrations = _this.parseMigrations(_this.migrations);\n          try {\n            request = indexedDB.open(_this.name, _this.version || migrations.length + 1);\n            if ((_this.CONNECTION_TIMEOUT != null) && _this.CONNECTION_TIMEOUT > -1) {\n              request.__timeout = setTimeout(function() {\n                request.__timedout = true;\n                return reject(new Error('Connection timed out'));\n              }, _this.CONNECTION_TIMEOUT);\n            }\n          } catch (error) {\n            e = error;\n            clearTimeout(request.__timeout);\n            return reject(e.message || e.name);\n          }\n          request.onupgradeneeded = function(e) {\n            var action, db, j, l, len, len1, migration, migrationTransaction, name1, ref, results, transaction;\n            clearTimeout(request.__timeout);\n            if (request.__timedout) {\n              return;\n            }\n            db = e.target.result;\n            transaction = e.target.transaction;\n            migrationTransaction = new Connection.Migration(db, transaction);\n            migrationTransaction.createObjectStore('migrations', {\n              keyPath: 'version'\n            });\n            results = [];\n            for (j = 0, len = migrations.length; j < len; j++) {\n              migration = migrations[j];\n              ref = migration.actions;\n              for (l = 0, len1 = ref.length; l < len1; l++) {\n                action = ref[l];\n                if (typeof migrationTransaction[name1 = action.type] === \"function\") {\n                  migrationTransaction[name1].apply(migrationTransaction, action.args);\n                }\n              }\n              results.push(transaction.objectStore('migrations').put(migration));\n            }\n            return results;\n          };\n          request.onsuccess = function(e) {\n            var db, objectStoreNames;\n            clearTimeout(request.__timeout);\n            if (request.__timedout) {\n              return;\n            }\n            db = e.target.result;\n            objectStoreNames = [].slice.call(db.objectStoreNames);\n            _this.createNamespaceForObjectStores(objectStoreNames);\n            db.onversionchange = function() {\n              return _this.close();\n            };\n            _this.database = db;\n            return resolve(objectStoreNames);\n          };\n          return request.onerror = function(e) {\n            return reject(request.error.message || request.error.name);\n          };\n        };\n      })(this));\n    };\n\n    API.prototype.close = function() {\n      return new Promise((function(_this) {\n        return function(resolve) {\n          if (_this.dbPromise) {\n            delete _this.dbPromise;\n          }\n          if (_this.database) {\n            _this.database.close();\n          }\n          return resolve();\n        };\n      })(this));\n    };\n\n    API.prototype.get = function(objectStoreName, key, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var promises;\n          if (Array.isArray(key)) {\n            promises = Promise.all(key.map(function(k) {\n              return _this.get(objectStoreName, k);\n            }));\n            return promises.then(resolve);\n          } else {\n            return _this.enqueue('read', objectStoreName, function(transaction) {\n              var request;\n              _this.logging.addRequest(transaction, 'get', objectStoreName, indexName, {\n                key: key\n              });\n              request = _this.createRequest({\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                indexName: indexName,\n                reject: reject\n              });\n              return request.get(key).onsuccess = function(e) {\n                var value;\n                clearTimeout(request.__timeout);\n                if (request.__timedout) {\n                  return;\n                }\n                value = e.target.result;\n                if (value === void 0) {\n                  value = null;\n                }\n                return resolve(value);\n              };\n            });\n          }\n        };\n      })(this));\n    };\n\n    API.prototype.getFirst = function(objectStoreName, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('read', objectStoreName, function(transaction) {\n            var request;\n            _this.logging.addRequest(transaction, 'getFirst', objectStoreName, indexName);\n            request = _this.createRequest({\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              indexName: indexName,\n              reject: reject\n            });\n            return request.openCursor().onsuccess = function(e) {\n              var cursor, value;\n              clearTimeout(request.__timeout);\n              if (request.__timedout) {\n                return;\n              }\n              if (cursor = e.target.result) {\n                value = cursor.value;\n                if (!request.keyPath) {\n                  value._key = cursor.key;\n                }\n                return resolve(value);\n              } else {\n                return resolve(null);\n              }\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.getAll = function(objectStoreName, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('read', objectStoreName, function(transaction) {\n            var request, result;\n            _this.logging.addRequest(transaction, 'getAll', objectStoreName, indexName);\n            result = [];\n            request = _this.createRequest({\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              indexName: indexName,\n              reject: reject\n            });\n            return request.openCursor().onsuccess = function(e) {\n              var cursor, value;\n              clearTimeout(request.__timeout);\n              if (request.__timedout) {\n                return;\n              }\n              if (!(cursor = e.target.result)) {\n                return resolve(result);\n              }\n              value = cursor.value;\n              if (!request.keyPath) {\n                value._key = cursor.key;\n              }\n              result.push(value);\n              return cursor[\"continue\"]();\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.count = function(objectStoreName, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('read', objectStoreName, function(transaction) {\n            var request;\n            _this.logging.addRequest(transaction, 'count', objectStoreName, indexName);\n            request = _this.createRequest({\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              indexName: indexName,\n              reject: reject\n            });\n            return request.count().onsuccess = function(e) {\n              var value;\n              clearTimeout(request.__timeout);\n              if (request.__timedout) {\n                return;\n              }\n              value = e.target.result;\n              if (!value) {\n                value = 0;\n              }\n              return resolve(value);\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.add = function(objectStoreName, key, data) {\n      var ref;\n      if (data === void 0) {\n        ref = [null, key], key = ref[0], data = ref[1];\n      }\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var promises;\n          if (!key && Array.isArray(data)) {\n            promises = Promise.all(data.map(function(d) {\n              return _this.add(objectStoreName, d);\n            }));\n            return promises.then(resolve);\n          } else if (key && Array.isArray(key) && Array.isArray(data)) {\n            promises = Promise.all(key.map(function(key, i) {\n              return _this.add(objectStoreName, key, data[i]);\n            }));\n            return promises.then(resolve);\n          } else {\n            return _this.enqueue('write', objectStoreName, function(transaction) {\n              var args, request;\n              _this.logging.addRequest(transaction, 'add', objectStoreName, null, {\n                key: key,\n                data: data\n              });\n              args = key ? [data, key] : [data];\n              request = _this.createRequest({\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                reject: reject\n              });\n              return request.put.apply(request, args).onsuccess = function(e) {\n                clearTimeout(request.__timeout);\n                if (request.__timedout) {\n                  return;\n                }\n                data._key = e.target.result;\n                return resolve(data);\n              };\n            });\n          }\n        };\n      })(this));\n    };\n\n    API.prototype.update = function(objectStoreName, key, value) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('write', objectStoreName, function(transaction) {\n            var getRequest;\n            _this.logging.addRequest(transaction, 'update', objectStoreName, null, {\n              key: key,\n              data: value\n            });\n            getRequest = _this.createRequest({\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              reject: reject\n            });\n            return getRequest.get(key).onsuccess = function(e) {\n              var args, data, deepUpdate, hasKeyPath, keyPath, putRequest;\n              clearTimeout(getRequest.__timeout);\n              if (getRequest.__timedout) {\n                return;\n              }\n              keyPath = e.target.source.keyPath;\n              hasKeyPath = !!keyPath;\n              data = e.target.result;\n              if (data === void 0) {\n                data = value;\n                if (hasKeyPath) {\n                  data[keyPath] = key;\n                }\n              } else {\n                deepUpdate = function(o, root) {\n                  var k, results, v;\n                  results = [];\n                  for (k in o) {\n                    v = o[k];\n                    if (typeof v === 'object') {\n                      deepUpdate(v, root[k]);\n                      continue;\n                    }\n                    results.push(root[k] = v);\n                  }\n                  return results;\n                };\n                deepUpdate(value, data);\n              }\n              args = hasKeyPath ? [data] : [data, key];\n              putRequest = _this.createRequest({\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                reject: reject\n              });\n              return putRequest.put.apply(putRequest, args).onsuccess = function() {\n                clearTimeout(putRequest.__timeout);\n                if (putRequest.__timedout) {\n                  return;\n                }\n                return resolve(data);\n              };\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.increment = function(objectStoreName, key, value, decrement) {\n      if (value == null) {\n        value = 1;\n      }\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('write', objectStoreName, function(transaction) {\n            var getRequest;\n            _this.logging.addRequest(transaction, (decrement ? 'decrement' : 'increment'), objectStoreName, null, {\n              key: key,\n              data: value\n            });\n            getRequest = _this.createRequest({\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              reject: reject\n            });\n            return getRequest.get(key).onsuccess = function(e) {\n              var args, data, deepIncrement, hasKeyPath, keyPath, putRequest;\n              clearTimeout(getRequest.__timeout);\n              if (getRequest.__timedout) {\n                return;\n              }\n              keyPath = e.target.source.keyPath;\n              hasKeyPath = !!keyPath;\n              data = e.target.result;\n              if (hasKeyPath) {\n                deepIncrement = function(o, root) {\n                  var k, results, v;\n                  results = [];\n                  for (k in o) {\n                    v = o[k];\n                    if (typeof v === 'object') {\n                      deepIncrement(v, root[k]);\n                      continue;\n                    }\n                    root[k] || (root[k] = 0);\n                    results.push(root[k] += decrement ? -v : v);\n                  }\n                  return results;\n                };\n                deepIncrement(value, data);\n              } else {\n                data || (data = 0);\n                data += decrement ? -value : value;\n              }\n              args = hasKeyPath ? [data] : [data, key];\n              putRequest = _this.createRequest({\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                reject: reject\n              });\n              return putRequest.put.apply(putRequest, args).onsuccess = function() {\n                clearTimeout(putRequest.__timeout);\n                if (putRequest.__timedout) {\n                  return;\n                }\n                return resolve(data);\n              };\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.decrement = function(objectStoreName, key, value) {\n      return this.increment(objectStoreName, key, value, true);\n    };\n\n    API.prototype[\"delete\"] = function(objectStoreName, key) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var promises;\n          if (Array.isArray(key)) {\n            promises = Promise.all(key.map(function(k) {\n              return _this[\"delete\"](objectStoreName, k);\n            }));\n            return promises.then(resolve);\n          } else {\n            return _this.enqueue('write', objectStoreName, function(transaction) {\n              var request;\n              _this.logging.addRequest(transaction, 'delete', objectStoreName, null, {\n                key: key\n              });\n              request = _this.createRequest({\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                reject: reject\n              });\n              return request[\"delete\"](key).onsuccess = function(e) {\n                clearTimeout(request.__timeout);\n                if (request.__timedout) {\n                  return;\n                }\n                return resolve(key);\n              };\n            });\n          }\n        };\n      })(this));\n    };\n\n    API.prototype.deleteWhere = function(objectStoreName, predicates, indexName) {\n      predicates.remove = true;\n      return this.where(objectStoreName, predicates, indexName);\n    };\n\n    API.prototype.clear = function(objectStoreName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('write', objectStoreName, function(transaction) {\n            var request;\n            _this.logging.addRequest(transaction, 'clear', objectStoreName);\n            request = _this.createRequest({\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              reject: reject\n            });\n            return request.clear().onsuccess = function() {\n              clearTimeout(request.__timeout);\n              if (request.__timedout) {\n                return;\n              }\n              return resolve();\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.clearAll = function() {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var objectStoreNames, promises;\n          objectStoreNames = slice.call(_this.database.objectStoreNames);\n          objectStoreNames = objectStoreNames.filter(function(objectStoreName) {\n            return objectStoreName !== 'migrations';\n          });\n          promises = Promise.all(objectStoreNames.map(function(objectStoreName) {\n            return _this.clear(objectStoreName);\n          }));\n          promises.then(resolve);\n          return promises[\"catch\"](reject);\n        };\n      })(this));\n    };\n\n    API.prototype.reset = function(objectStoreName, key, data) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var clearPromise;\n          clearPromise = _this.clear(objectStoreName);\n          clearPromise[\"catch\"](reject);\n          return clearPromise.then(function() {\n            var addPromise;\n            addPromise = _this.add(objectStoreName, key, data);\n            addPromise[\"catch\"](reject);\n            return addPromise.then(resolve);\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.index = function(objectStoreName, indexName) {\n      return this.createNamespaceForIndex(indexName, objectStoreName);\n    };\n\n    API.prototype.where = function(objectStoreName, predicates, indexName) {\n      var readWrite;\n      readWrite = predicates.remove ? 'write' : 'read';\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue(readWrite, objectStoreName, function(transaction) {\n            var bound, bounds, contains, count, eq, eqIsArray, exact, except, gt, gteq, hasValues, isEquivalent, isInclusive, isLowerBound, k, knownUniques, limit, lower, lt, lteq, offset, only, order, range, ref, remove, request, result, uniq, uniques, upper, v;\n            _this.logging.addRequest(transaction, 'where', objectStoreName, indexName, {\n              data: predicates\n            });\n            lt = predicates.lt, lteq = predicates.lteq, gt = predicates.gt, gteq = predicates.gteq, eq = predicates.eq, limit = predicates.limit, offset = predicates.offset, only = predicates.only, contains = predicates.contains, except = predicates.except, uniq = predicates.uniq, order = predicates.order, remove = predicates.remove;\n            uniques = Array.isArray(uniq) ? uniq : uniq ? [uniq] : [];\n            order = order === 'desc' ? 'prev' : 'next';\n            bounds = {};\n            ref = {\n              lt: lt,\n              lteq: lteq,\n              gt: gt,\n              gteq: gteq,\n              eq: eq\n            };\n            for (k in ref) {\n              v = ref[k];\n              if (v === void 0) {\n                continue;\n              }\n              isInclusive = k === 'gteq' || k === 'lteq';\n              isEquivalent = k === 'eq';\n              isLowerBound = k === 'gt' || k === 'gteq';\n              bound = isEquivalent ? 'exact' : isLowerBound ? 'lower' : 'upper';\n              bounds[bound] = {\n                value: v,\n                open: !isInclusive\n              };\n            }\n            range = null;\n            eqIsArray = false;\n            lower = bounds.lower, upper = bounds.upper, exact = bounds.exact;\n            if (exact) {\n              if (eqIsArray = Array.isArray(eq)) {\n                eq.sort();\n                lower = {\n                  value: eq[0],\n                  open: false\n                };\n                upper = {\n                  value: eq[eq.length - 1],\n                  open: false\n                };\n                range = IDBKeyRange.bound(lower.value, upper.value, lower.open, upper.open);\n              } else {\n                range = IDBKeyRange.only(exact.value);\n              }\n            } else if (lower && upper) {\n              range = IDBKeyRange.bound(lower.value, upper.value, lower.open, upper.open);\n            } else if (lower) {\n              range = IDBKeyRange.lowerBound(lower.value, lower.open);\n            } else if (upper) {\n              range = IDBKeyRange.upperBound(upper.value, upper.open);\n            }\n            result = [];\n            count = 0;\n            knownUniques = {};\n            hasValues = function(object, k, v) {\n              if (!Array.isArray(v)) {\n                v = [v];\n              }\n              return v.indexOf(object[k]) !== -1;\n            };\n            request = _this.createRequest({\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              indexName: indexName,\n              reject: reject\n            });\n            request = range ? request.openCursor(range, order) : request.openCursor();\n            return request.onsuccess = function(e) {\n              var a, cursor, j, keyPath, knownValues, len, value;\n              clearTimeout(request.__timeout);\n              if (request.__timedout) {\n                return;\n              }\n              if (!(cursor = e.target.result)) {\n                return resolve(result);\n              }\n              value = cursor.value;\n              if (eqIsArray) {\n                keyPath = e.target.source.keyPath;\n                only || (only = {});\n                only[keyPath] = eq;\n              }\n              for (k in only) {\n                v = only[k];\n                if (!hasValues(value, k, v)) {\n                  return cursor[\"continue\"]();\n                }\n              }\n              for (k in contains) {\n                v = contains[k];\n                if (!Array.isArray(v)) {\n                  v = [v];\n                }\n                a = value[k];\n                if (!Array.isArray(a)) {\n                  a = [a];\n                }\n                if (!_this.intersect(a, v).length) {\n                  return cursor[\"continue\"]();\n                }\n              }\n              for (k in except) {\n                v = except[k];\n                if (hasValues(value, k, v)) {\n                  return cursor[\"continue\"]();\n                }\n              }\n              for (j = 0, len = uniques.length; j < len; j++) {\n                k = uniques[j];\n                knownValues = knownUniques[k] || (knownUniques[k] = []);\n                if (knownValues.indexOf(value[k]) !== -1) {\n                  return cursor[\"continue\"]();\n                }\n                knownUniques[k].push(value[k]);\n              }\n              count++;\n              if (offset && count <= offset) {\n                return cursor[\"continue\"]();\n              }\n              result.push(value);\n              if (remove) {\n                cursor[\"delete\"]();\n              }\n              if (limit) {\n                if (typeof limit === 'function' && limit(result)) {\n                  return resolve(result);\n                } else if (limit === result.length) {\n                  return resolve(result);\n                }\n              }\n              return cursor[\"continue\"]();\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.getMethodsForObjectStore = function() {\n      return this._getMethodsForObjectStore || (this._getMethodsForObjectStore = ['get', 'getFirst', 'getAll', 'count', 'add', 'update', 'increment', 'decrement', 'delete', 'deleteWhere', 'clear', 'reset', 'index', 'where']);\n    };\n\n    API.prototype.getMethodsForIndex = function() {\n      return this._getMethodsForIndex || (this._getMethodsForIndex = ['get', 'getFirst', 'getAll', 'count', 'where', 'deleteWhere']);\n    };\n\n    API.prototype.createNamespaceForObjectStores = function(objectStoreNames, context) {\n      var j, len, objectStoreName, results;\n      if (objectStoreNames == null) {\n        objectStoreNames = [];\n      }\n      if (context == null) {\n        context = this;\n      }\n      results = [];\n      for (j = 0, len = objectStoreNames.length; j < len; j++) {\n        objectStoreName = objectStoreNames[j];\n        if (objectStoreName === 'migrations') {\n          continue;\n        }\n        results.push(this.createNamespaceForObjectStore(objectStoreName, context));\n      }\n      return results;\n    };\n\n    API.prototype.createNamespaceForObjectStore = function(objectStoreName, context) {\n      var namespace;\n      if (context == null) {\n        context = this;\n      }\n      namespace = context[objectStoreName] = {};\n      this.getMethodsForObjectStore().forEach((function(_this) {\n        return function(method) {\n          return namespace[method] = function() {\n            return context[method].apply(context, [objectStoreName].concat(slice.call(arguments)));\n          };\n        };\n      })(this));\n      return namespace;\n    };\n\n    API.prototype.createNamespaceForIndex = function(indexName, objectStoreName, context) {\n      var namespace;\n      if (context == null) {\n        context = this;\n      }\n      namespace = {};\n      this.getMethodsForIndex().forEach((function(_this) {\n        return function(method) {\n          return namespace[method] = function() {\n            return context[method].apply(context, [objectStoreName].concat(slice.call(arguments), [indexName]));\n          };\n        };\n      })(this));\n      return namespace;\n    };\n\n    API.prototype.createRequest = function(arg) {\n      var indexName, objectStore, objectStoreName, reject, request, transaction;\n      transaction = arg.transaction, objectStoreName = arg.objectStoreName, indexName = arg.indexName, reject = arg.reject;\n      objectStore = transaction.objectStore(objectStoreName);\n      request = indexName ? objectStore.index(indexName) : objectStore;\n      if (reject && (this.REQUEST_TIMEOUT != null) && this.REQUEST_TIMEOUT > -1) {\n        request.__timeout = setTimeout(function() {\n          request.__timedout = true;\n          return reject(new Error('Request timed out'));\n        }, this.REQUEST_TIMEOUT);\n      }\n      return request;\n    };\n\n    API.prototype.createTransaction = function(mode, objectStoreName, callback) {\n      return this.open().then((function(_this) {\n        return function() {\n          var transaction;\n          transaction = _this.database.transaction([objectStoreName], mode);\n          return callback(transaction);\n        };\n      })(this))[\"catch\"]((function(_this) {\n        return function(err) {\n          throw err;\n        };\n      })(this));\n    };\n\n    API.prototype.intersect = function(a, b) {\n      var ai, bi, result;\n      ai = 0;\n      bi = 0;\n      result = [];\n      while (ai < a.length && bi < b.length) {\n        if (a[ai] < b[bi]) {\n          ai++;\n        } else if (a[ai] > b[bi]) {\n          bi++;\n        } else {\n          result.push(a[ai]);\n          ai++;\n          bi++;\n        }\n      }\n      return result;\n    };\n\n    API.prototype.enqueue = function(readwrite, objectStoreName, callback) {\n      var base, request;\n      (base = this.queue)[objectStoreName] || (base[objectStoreName] = []);\n      request = {\n        readwrite: readwrite,\n        callback: callback\n      };\n      if (!this.queue[objectStoreName].length) {\n        this.scheduleTransaction(objectStoreName);\n      }\n      return this.queue[objectStoreName].push(request);\n    };\n\n    API.prototype.scheduleTransaction = function(objectStoreName) {\n      return setTimeout((function(_this) {\n        return function() {\n          var mode, modes, needsWriteMode, requests;\n          requests = _this.queue[objectStoreName].splice(0);\n          modes = requests.map(function(r) {\n            return r.readwrite;\n          });\n          needsWriteMode = modes.some(function(m) {\n            return m === 'write';\n          });\n          mode = needsWriteMode ? 'readwrite' : 'readonly';\n          return _this.createTransaction(mode, objectStoreName, function(transaction) {\n            var j, len, request, results;\n            _this.logging.addTransaction(transaction, objectStoreName);\n            results = [];\n            for (j = 0, len = requests.length; j < len; j++) {\n              request = requests[j];\n              results.push(request.callback(transaction));\n            }\n            return results;\n          });\n        };\n      })(this), 0);\n    };\n\n    return API;\n\n  })();\n  Connection.Migration = (function() {\n    function Migration(db1, transaction1) {\n      this.db = db1;\n      this.transaction = transaction1;\n    }\n\n    Migration.prototype.createObjectStore = function(name, options) {\n      if (this.db.objectStoreNames.contains(name)) {\n        return;\n      }\n      return this.db.createObjectStore(name, options);\n    };\n\n    Migration.prototype.deleteObjectStore = function(name) {\n      if (!this.db.objectStoreNames.contains(name)) {\n        return;\n      }\n      return this.db.deleteObjectStore(name);\n    };\n\n    Migration.prototype.createIndex = function(objectStoreName, indexName, keyPath, options) {\n      var objectStore;\n      objectStore = this.transaction.objectStore(objectStoreName);\n      if (objectStore && objectStore.indexNames.contains(indexName)) {\n        return;\n      }\n      return objectStore.createIndex(indexName, keyPath, options);\n    };\n\n    Migration.prototype.deleteIndex = function(objectStoreName, indexName) {\n      var objectStore;\n      objectStore = this.transaction.objectStore(objectStoreName);\n      if (!(objectStore && objectStore.indexNames.contains(indexName))) {\n        return;\n      }\n      return objectStore.deleteIndex(indexName);\n    };\n\n    return Migration;\n\n  })();\n  Connection.Logging = (function() {\n    function Logging() {\n      this.queues = [];\n    }\n\n    Logging.prototype.addTransaction = function(transaction, objectStoreNames) {\n      var callback;\n      if (!this.handleLog) {\n        return;\n      }\n      this.queues.push({\n        transaction: transaction,\n        objectStoreNames: objectStoreNames,\n        requests: [],\n        start: Date.now()\n      });\n      callback = (function(_this) {\n        return function(e) {\n          return _this.logTransaction(e.target);\n        };\n      })(this);\n      transaction.onabort = callback;\n      transaction.onerror = callback;\n      return transaction.oncomplete = callback;\n    };\n\n    Logging.prototype.addRequest = function(transaction, method, objectStoreName, indexName, data) {\n      var queue;\n      if (!this.handleLog) {\n        return;\n      }\n      queue = this.queues.filter(function(q) {\n        return q.transaction === transaction;\n      })[0];\n      if (!queue) {\n        return;\n      }\n      return queue.requests.push({\n        method: method,\n        objectStoreName: objectStoreName,\n        indexName: indexName,\n        data: data\n      });\n    };\n\n    Logging.prototype.logTransaction = function(transaction) {\n      var data, end, indexName, j, key, len, logs, method, mode, objectStoreName, queue, ref, ref1, request, requestsLenght, time;\n      if (!this.handleLog) {\n        return;\n      }\n      queue = this.queues.filter(function(q) {\n        return q.transaction === transaction;\n      })[0];\n      if (!queue) {\n        return;\n      }\n      mode = queue.transaction.mode === 'readwrite' ? 'write' : 'read ';\n      requestsLenght = queue.requests.length;\n      end = Date.now();\n      time = end - queue.start;\n      this.handleLog({\n        type: 'transaction.start',\n        data: \"Ndex: \" + mode + \" \" + queue.objectStoreNames + \" \" + time + \"ms (\" + requestsLenght + \" request\" + (requestsLenght > 1 ? 's' : '') + \")\"\n      });\n      ref = queue.requests;\n      for (j = 0, len = ref.length; j < len; j++) {\n        request = ref[j];\n        method = request.method, objectStoreName = request.objectStoreName, indexName = request.indexName, data = request.data;\n        if (data) {\n          ref1 = data, key = ref1.key, data = ref1.data;\n        }\n        logs = [];\n        switch (method) {\n          case 'get':\n            logs = ['GET', key, 'FROM', objectStoreName];\n            break;\n          case 'getFirst':\n            logs = ['GET FIRST', key, 'FROM', objectStoreName];\n            break;\n          case 'getAll':\n            logs = ['GET ALL', 'FROM', objectStoreName];\n            break;\n          case 'count':\n            logs = ['COUNT', 'FROM', objectStoreName];\n            break;\n          case 'add':\n            logs = ['ADD', JSON.stringify(data), 'TO', objectStoreName];\n            if (key) {\n              logs = logs.concat(['WITH KEY', key]);\n            }\n            break;\n          case 'update':\n            logs = ['UPDATE', key, 'FROM', objectStoreName, 'SET', JSON.stringify(data)];\n            break;\n          case 'increment':\n            if (typeof data === 'object') {\n              data = JSON.stringify(data);\n            }\n            logs = ['INCREMENT', data, 'TO KEY', key, 'FROM', objectStoreName];\n            break;\n          case 'decrement':\n            if (typeof data === 'object') {\n              data = JSON.stringify(data);\n            }\n            logs = ['DECREMENT', data, 'TO KEY', key, 'FROM', objectStoreName];\n            break;\n          case 'delete':\n            logs = ['DELETE', key, 'FROM', objectStoreName];\n            break;\n          case 'clear':\n            logs = ['CLEAR', objectStoreName];\n            break;\n          case 'where':\n            if (typeof data.limit === 'function') {\n              data.limit = '[FUNCTION]';\n            }\n            logs = ['WHERE', JSON.stringify(data), 'FROM', objectStoreName];\n        }\n        if (indexName) {\n          logs = logs.concat(['INDEX', indexName]);\n        }\n        this.handleLog({\n          type: 'request',\n          data: logs.join(' ')\n        });\n      }\n      return this.handleLog({\n        type: 'transaction.end'\n      });\n    };\n\n    return Logging;\n\n  })();\n  return Connection.API;\n};\n\nif (typeof exports !== 'undefined') {\n  module.exports = factory();\n} else {\n  this.Connection = factory();\n}\n";
},function(e,t){e.exports="var handleLogging, init;\n\ninit = function(arg) {\n  var migrations, name;\n  name = arg.name, migrations = arg.migrations;\n  return this.connection = new Connection(name, migrations);\n};\n\nhandleLogging = function() {\n  return this.connection.logging.handleLog = function(args) {\n    return postMessage({\n      method: 'handleLog',\n      args: args\n    });\n  };\n};\n\nself.onmessage = (function(_this) {\n  return function(e) {\n    var data;\n    data = e.data;\n    if (!Array.isArray(data)) {\n      data = [data];\n    }\n    return data.forEach(function(datum) {\n      var args, id, method;\n      id = datum.id, method = datum.method, args = datum.args;\n      if (typeof _this[method] === 'function') {\n        return _this[method](args);\n      }\n      return _this.connection[method].apply(_this.connection, args).then(function(data) {\n        return postMessage({\n          id: id,\n          resolve: data\n        });\n      })[\"catch\"](function(data) {\n        return postMessage({\n          id: id,\n          reject: data\n        });\n      });\n    });\n  };\n})(this);\n"}])});