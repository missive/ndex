!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.Ndex=n():e.Ndex=n()}(this,function(){return function(e){function n(r){if(t[r])return t[r].exports;var o=t[r]={exports:{},id:r,loaded:!1};return e[r].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var t={};return n.m=e,n.c=t,n.p="",n(0)}([function(e,n,t){var r,o,a,i;o=t(1),r=t(2),i=t(4),a=function(){function e(){this.connections={}}return e.prototype.connect=function(e,n,t){return null==t&&(t=null),new Promise(function(a){return function(s,u){var c;if(!t){if(c=a.connections[e])return u(new Error("Already connected to “"+e+"”"));c=new o(e,n),t=a.connections[e]=a.getAdapter(c)}return t.handleMethod("open").then(function(e){return t.proxyObjectStoresNamespace(e),s(t)}).catch(function(n){return t instanceof i?(t=a.connections[e]=new r(c),console.info("Ndex: Fallbacking to BrowserAdapter for “"+e+"” because “"+n+"”"),s(a.connect(null,null,t))):u("Ndex: "+n)})}}(this))},e.prototype.getAdapter=function(e){var n;return new(n=this.getAdapterClass())(e)},e.prototype.getAdapterClass=function(){return this.workersAreSupported()?i:r},e.prototype.workersAreSupported=function(e){return null==e&&(e=window),null!=this._workersAreSupported?this._workersAreSupported:this._workersAreSupported="Worker"in e},e}(),e.exports=new a},function(e,n,t){var r,o=[].slice;r=function(){var e;return e={},e.API=function(){function n(n,t){this.name=n,this.migrations=t,this.database=null,this.queue={},this.logging=new e.Logging}return n.prototype.CONNECTION_TIMEOUT=3e3,n.prototype.REQUEST_TIMEOUT=3e3,n.prototype.parseMigrations=function(e){var n,t;return(t=e.version)&&(this.version=t,delete e.version),n=Object.keys(e).sort(),n.map(function(n){return function(n){var r,o,a;return t=parseInt(n),a=n.match(/_(.+)/),o=a?a[1].replace(/(\w)([A-Z])/g,function(e,n,t){return n+" "+t.toLowerCase()}):"",r=e[n]||[],Array.isArray(r)||(r=[r]),{version:t,title:o,actions:r,key:n}}}(this))},n.prototype.deleteDatabase=function(){return new Promise(function(e){return function(n){var t;return e.database?(e.close(),t=indexedDB.deleteDatabase(e.database.name),t.onsuccess=function(e){return setTimeout(function(){return n()},0)}):n()}}(this))},n.prototype.open=function(n){var t;return t=(null!=n?n:{}).withoutVersion,this.dbPromise?this.dbPromise:this.dbPromise=new Promise(function(n){return function(r,o){var a,i,s,u;if(!self.indexedDB)return o("indexedDB isn’t supported");i=n.parseMigrations(n.migrations);try{u=t?void 0:n.version||i.length+1,s=indexedDB.open(n.name,u),null!=n.CONNECTION_TIMEOUT&&n.CONNECTION_TIMEOUT>-1&&(s.__timeout=setTimeout(function(){return s.__timedout=!0,o(new Error("Connection timed out"))},n.CONNECTION_TIMEOUT))}catch(e){return a=e,clearTimeout(s.__timeout),o(a.message||a.name)}return s.onupgradeneeded=function(n){var t,r,o,a,u,c,l,d,m,h,p,f;if(clearTimeout(s.__timeout),!s.__timedout){for(r=n.target.result,f=n.target.transaction,d=new e.Migration(r,f),d.createObjectStore("migrations",{keyPath:"version"}),p=[],o=0,u=i.length;o<u;o++){for(l=i[o],h=l.actions,a=0,c=h.length;a<c;a++)t=h[a],"function"==typeof d[m=t.type]&&d[m].apply(d,t.args);p.push(f.objectStore("migrations").put(l))}return p}},s.onsuccess=function(e){var t,o;if(clearTimeout(s.__timeout),!s.__timedout)return t=e.target.result,o=[].slice.call(t.objectStoreNames),n.createNamespaceForObjectStores(o),t.onversionchange=function(){return n.close()},n.database=t,r(o)},s.onerror=function(e){return t||"VersionError"!==s.error.name?o(s.error.message||s.error.name):(n.close(),n.open({withoutVersion:!0}).then(r).catch(o))}}}(this))},n.prototype.close=function(){if(this.dbPromise&&delete this.dbPromise,this.database)return this.database.close()},n.prototype.get=function(e,n,t){return new Promise(function(r){return function(o,a){var i;return Array.isArray(n)?(i=Promise.all(n.map(function(n){return r.get(e,n)})),i.then(o)):r.enqueue("read",e,a,function(i){var s;return r.logging.addRequest(i,"get",e,t,{key:n}),s={method:"get",args:n,transaction:i,reject:a,objectStoreName:e,indexName:t},r.createRequest(s,function(e){var n;return n=e.target.result,void 0===n&&(n=null),o(n)})})}}(this))},n.prototype.getFirst=function(e,n){return new Promise(function(t){return function(r,o){return t.enqueue("read",e,o,function(a){var i;return t.logging.addRequest(a,"getFirst",e,n),i={method:"openCursor",transaction:a,reject:o,objectStoreName:e,indexName:n},t.createRequest(i,function(e){var n,t,o,a;return o=e.target,t=o.source,(n=o.result)?(a=n.value,t.keyPath||(a._key=n.key),r(a)):r(null)})})}}(this))},n.prototype.getAll=function(e,n){return new Promise(function(t){return function(r,o){return t.enqueue("read",e,o,function(a){var i,s;return t.logging.addRequest(a,"getAll",e,n),s=[],i={method:"openCursor",transaction:a,reject:o,objectStoreName:e,indexName:n},t.createRequest(i,function(e){var n,t,o,a;return o=e.target,t=o.source,(n=e.target.result)?(a=n.value,t.keyPath||(a._key=n.key),s.push(a),n.continue()):r(s)})})}}(this))},n.prototype.count=function(e,n){return new Promise(function(t){return function(r,o){return t.enqueue("read",e,o,function(a){var i;return t.logging.addRequest(a,"count",e,n),i={method:"count",transaction:a,reject:o,objectStoreName:e,indexName:n},t.createRequest(i,function(e){var n;return n=e.target.result,n||(n=0),r(n)})})}}(this))},n.prototype.add=function(e,n,t){var r;return void 0===t&&(r=[null,n],n=r[0],t=r[1]),new Promise(function(r){return function(o,a){var i;return!n&&Array.isArray(t)?(i=Promise.all(t.map(function(n){return r.add(e,n)})),i.then(o)):n&&Array.isArray(n)&&Array.isArray(t)?(i=Promise.all(n.map(function(n,o){return r.add(e,n,t[o])})),i.then(o)):r.enqueue("write",e,a,function(i){var s,u;return r.logging.addRequest(i,"add",e,null,{key:n,data:t}),s=n?[t,n]:[t],u={method:"put",args:s,transaction:i,objectStoreName:e,reject:a},r.createRequest(u,function(e){return t._key=e.target.result,o(t)})})}}(this))},n.prototype.update=function(e,n,t){return new Promise(function(r){return function(o,a){return r.enqueue("write",e,a,function(i){var s;return r.logging.addRequest(i,"update",e,null,{key:n,data:t}),s={method:"get",args:n,transaction:i,objectStoreName:e,reject:a},r.createRequest(s,function(u){var c,l,d,m,h,p,f;return f=u.target,p=f.source,h=p.keyPath,m=!!h,l=f.result,void 0===l?(l=t,m&&(l[h]=n)):(d=function(e,n){var t,r,o;r=[];for(t in e)o=e[t],"object"!=typeof o?r.push(n[t]=o):d(o,n[t]);return r})(t,l),c=m?[l]:[l,n],s={method:"put",args:c,transaction:i,objectStoreName:e,reject:a},r.createRequest(s,function(e){return o(l)})})})}}(this))},n.prototype.increment=function(e,n,t,r){return null==t&&(t=1),new Promise(function(o){return function(a,i){return o.enqueue("write",e,i,function(s){var u;return o.logging.addRequest(s,r?"decrement":"increment",e,null,{key:n,data:t}),u={method:"get",args:n,transaction:s,objectStoreName:e,reject:i},o.createRequest(u,function(c){var l,d,m,h,p,f,g;return g=c.target,f=g.source,p=f.keyPath,h=!!p,d=g.result,h?(m=function(e,n){var t,o,a;o=[];for(t in e)a=e[t],"object"!=typeof a?(n[t]||(n[t]=0),o.push(n[t]+=r?-a:a)):m(a,n[t]);return o})(t,d):(d||(d=0),d+=r?-t:t),l=h?[d]:[d,n],u={method:"put",args:l,transaction:s,objectStoreName:e,reject:i},o.createRequest(u,function(e){return a(d)})})})}}(this))},n.prototype.decrement=function(e,n,t){return this.increment(e,n,t,!0)},n.prototype.delete=function(e,n){return new Promise(function(t){return function(r,o){var a;return Array.isArray(n)?(a=Promise.all(n.map(function(n){return t.delete(e,n)})),a.then(r)):t.enqueue("write",e,o,function(a){var i;return t.logging.addRequest(a,"delete",e,null,{key:n}),i={method:"delete",args:n,transaction:a,objectStoreName:e,reject:o},t.createRequest(i,function(e){return r(n)})})}}(this))},n.prototype.deleteWhere=function(e,n,t){return n.remove=!0,this.where(e,n,t)},n.prototype.clear=function(e){return new Promise(function(n){return function(t,r){return n.enqueue("write",e,r,function(o){var a;return n.logging.addRequest(o,"clear",e),a={method:"clear",transaction:o,objectStoreName:e,reject:r},n.createRequest(a,function(e){return t()})})}}(this))},n.prototype.clearAll=function(){return new Promise(function(e){return function(n,t){var r,a;return r=o.call(e.database.objectStoreNames),r=r.filter(function(e){return"migrations"!==e}),a=Promise.all(r.map(function(n){return e.clear(n)})),a.then(n),a.catch(t)}}(this))},n.prototype.reset=function(e,n,t){return new Promise(function(r){return function(o,a){var i;return i=r.clear(e),i.catch(a),i.then(function(){var i;return i=r.add(e,n,t),i.catch(a),i.then(o)})}}(this))},n.prototype.index=function(e,n){return this.createNamespaceForIndex(n,e)},n.prototype.where=function(e,n,t){var r;return r=n.remove?"write":"read",new Promise(function(o){return function(a,i){return o.enqueue(r,e,i,function(r){var s,u,c,l,d,m,h,p,f,g,b,j,y,v,N,S,q,k,_,x,w,P,A,I,T,O,E,R,M,F,L,C,U;o.logging.addRequest(r,"where",e,t,{data:n}),x=n.lt,w=n.lteq,g=n.gt,b=n.gteq,m=n.eq,k=n.limit,P=n.offset,A=n.only,l=n.contains,f=n.except,F=n.uniq,I=n.order,R=n.remove,L=Array.isArray(F)?F:F?[F]:[],I="desc"===I?"prev":"next",c={},E={lt:x,lteq:w,gt:g,gteq:b,eq:m};for(S in E)U=E[S],void 0!==U&&(v="gteq"===S||"lteq"===S,y="eq"===S,N="gt"===S||"gteq"===S,u=y?"exact":N?"lower":"upper",c[u]={value:U,open:!v});return O=null,h=!1,_=c.lower,C=c.upper,p=c.exact,p?(h=Array.isArray(m))?(m.sort(),_={value:m[0],open:!1},C={value:m[m.length-1],open:!1},O=IDBKeyRange.bound(_.value,C.value,_.open,C.open)):O=IDBKeyRange.only(p.value):_&&C?O=IDBKeyRange.bound(_.value,C.value,_.open,C.open):_?O=IDBKeyRange.lowerBound(_.value,_.open):C&&(O=IDBKeyRange.upperBound(C.value,C.open)),M=[],d=0,q={},j=function(e,n,t){return Array.isArray(t)||(t=[t]),t.indexOf(e[n])!==-1},s=O?[O,I]:void 0,T={method:"openCursor",args:s,transaction:r,reject:i,objectStoreName:e,indexName:t},o.createRequest(T,function(e){var n,t,r,i,s,u,c,p;if(c=e.target,u=c.source,!(t=e.target.result))return a(M);p=t.value,h&&(A||(A={}),A[u.keyPath]=m);for(S in A)if(U=A[S],!j(p,S,U))return t.continue();for(S in l)if(U=l[S],Array.isArray(U)||(U=[U]),n=p[S],Array.isArray(n)||(n=[n]),!o.intersect(n,U).length)return t.continue();for(S in f)if(U=f[S],j(p,S,U))return t.continue();for(r=0,s=L.length;r<s;r++){if(S=L[r],i=q[S]||(q[S]=[]),i.indexOf(p[S])!==-1)return t.continue();q[S].push(p[S])}if(d++,P&&d<=P)return t.continue();if(M.push(p),R&&t.delete(),k){if("function"==typeof k&&k(M))return a(M);if(k===M.length)return a(M)}return t.continue()})})}}(this))},n.prototype.getMethodsForObjectStore=function(){return this._getMethodsForObjectStore||(this._getMethodsForObjectStore=["get","getFirst","getAll","count","add","update","increment","decrement","delete","deleteWhere","clear","reset","index","where"])},n.prototype.getMethodsForIndex=function(){return this._getMethodsForIndex||(this._getMethodsForIndex=["get","getFirst","getAll","count","where","deleteWhere"])},n.prototype.createNamespaceForObjectStores=function(e,n){var t,r,o,a;for(null==e&&(e=[]),null==n&&(n=this),a=[],t=0,r=e.length;t<r;t++)o=e[t],"migrations"!==o&&a.push(this.createNamespaceForObjectStore(o,n));return a},n.prototype.createNamespaceForObjectStore=function(e,n){var t;return null==n&&(n=this),t=n[e]={},this.getMethodsForObjectStore().forEach(function(r){return function(r){return t[r]=function(){return n[r].apply(n,[e].concat(o.call(arguments)))}}}(this)),t},n.prototype.createNamespaceForIndex=function(e,n,t){var r;return null==t&&(t=this),r={},this.getMethodsForIndex().forEach(function(a){return function(a){return r[a]=function(){return t[a].apply(t,[n].concat(o.call(arguments),[e]))}}}(this)),r},n.prototype.getObjectStore=function(e){var n,t,r,o;return o=e.transaction,r=e.objectStoreName,n=e.indexName,t=o.objectStore(r),n?t.index(n):t},n.prototype.createRequest=function(e,n){var t,r,o,a,i,s,u,c;return o=e.method,t=e.args,c=e.transaction,i=e.objectStoreName,r=e.indexName,s=e.reject,a=c.objectStore(i),r&&(a=a.index(r)),Array.isArray(t)||(t=[t]),u=a[o].apply(a,t),null!=this.REQUEST_TIMEOUT&&this.REQUEST_TIMEOUT>-1&&(u.__timeout=setTimeout(function(){return u.__timedout=!0,"function"==typeof s?s(new Error("Request timed out")):void 0},this.REQUEST_TIMEOUT)),u.onsuccess=function(e){if(clearTimeout(u.__timeout),!u.__timedout)return n(e)},u.onerror=function(e){if(clearTimeout(u.__timeout),!u.__timedout)return"function"==typeof s?s(u.error):void 0},u},n.prototype.createTransaction=function(e,n,t){return this.open().then(function(r){return function(){var o,a;try{a=r.database.transaction([n],e)}catch(e){o=e}return t(a)}}(this)).catch(function(e){return function(e){throw e}}(this))},n.prototype.intersect=function(e,n){var t,r,o;for(t=0,r=0,o=[];t<e.length&&r<n.length;)e[t]<n[r]?t++:e[t]>n[r]?r++:(o.push(e[t]),t++,r++);return o},n.prototype.enqueue=function(e,n,t,r){var o,a;return(o=this.queue)[n]||(o[n]=[]),a={readwrite:e,objectStoreName:n,reject:t,callback:r},this.queue[n].length||this.scheduleTransaction(n),this.queue[n].push(a)},n.prototype.scheduleTransaction=function(e){return setTimeout(function(n){return function(){var t,r,o,a;return a=n.queue[e].splice(0),r=a.map(function(e){return e.readwrite}),o=r.some(function(e){return"write"===e}),t=o?"readwrite":"readonly",n.createTransaction(t,e,function(t){var r,o,i,s,u;for(n.logging.addTransaction(t,e),u=[],o=0,i=a.length;o<i;o++){s=a[o];try{u.push(s.callback(t))}catch(e){r=e,u.push(s.reject(r))}}return u})}}(this),0)},n}(),e.Migration=function(){function e(e,n){this.db=e,this.transaction=n}return e.prototype.createObjectStore=function(e,n){if(!this.db.objectStoreNames.contains(e))return this.db.createObjectStore(e,n)},e.prototype.deleteObjectStore=function(e){if(this.db.objectStoreNames.contains(e))return this.db.deleteObjectStore(e)},e.prototype.createIndex=function(e,n,t,r){var o;if(o=this.transaction.objectStore(e),!o||!o.indexNames.contains(n))return o.createIndex(n,t,r)},e.prototype.deleteIndex=function(e,n){var t;if(t=this.transaction.objectStore(e),t&&t.indexNames.contains(n))return t.deleteIndex(n)},e}(),e.Logging=function(){function e(){this.queues=[]}return e.prototype.addTransaction=function(e,n){var t;if(e&&this.handleLog)return this.queues.push({transaction:e,objectStoreNames:n,requests:[],start:Date.now()}),t=function(e){return function(n){return e.logTransaction(n.target)}}(this),e.onabort=t,e.onerror=t,e.oncomplete=t},e.prototype.addRequest=function(e,n,t,r,o){var a;if(e&&this.handleLog&&(a=this.queues.filter(function(n){return n.transaction===e})[0]))return a.requests.push({method:n,objectStoreName:t,indexName:r,data:o})},e.prototype.logTransaction=function(e){var n,t,r,o,a,i,s,u,c,l,d,m,h,p,f,g;if(e&&this.handleLog&&(d=this.queues.filter(function(n){return n.transaction===e})[0])){for(c="readwrite"===d.transaction.mode?"write":"read ",f=d.requests.length,t=Date.now(),g=t-d.start,this.handleLog({type:"transaction.start",data:"Ndex: "+c+" "+d.objectStoreNames+" "+g+"ms ("+f+" request"+(f>1?"s":"")+")"}),m=d.requests,o=0,i=m.length;o<i;o++){switch(p=m[o],u=p.method,l=p.objectStoreName,r=p.indexName,n=p.data,n&&(h=n,a=h.key,n=h.data),s=[],u){case"get":s=["GET",a,"FROM",l];break;case"getFirst":s=["GET FIRST",a,"FROM",l];break;case"getAll":s=["GET ALL","FROM",l];break;case"count":s=["COUNT","FROM",l];break;case"add":s=["ADD",JSON.stringify(n),"TO",l],a&&(s=s.concat(["WITH KEY",a]));break;case"update":s=["UPDATE",a,"FROM",l,"SET",JSON.stringify(n)];break;case"increment":"object"==typeof n&&(n=JSON.stringify(n)),s=["INCREMENT",n,"TO KEY",a,"FROM",l];break;case"decrement":"object"==typeof n&&(n=JSON.stringify(n)),s=["DECREMENT",n,"TO KEY",a,"FROM",l];break;case"delete":s=["DELETE",a,"FROM",l];break;case"clear":s=["CLEAR",l];break;case"where":"function"==typeof n.limit&&(n.limit="[FUNCTION]"),s=["WHERE",JSON.stringify(n),"FROM",l]}r&&(s=s.concat(["INDEX",r])),this.handleLog({type:"request",data:s.join(" ")})}return this.handleLog({type:"transaction.end"})}},e}(),e.API},e.exports=r()},function(e,n,t){var r,o,a=function(e,n){function t(){this.constructor=e}for(var r in n)i.call(n,r)&&(e[r]=n[r]);return t.prototype=n.prototype,e.prototype=new t,e.__super__=n.prototype,e},i={}.hasOwnProperty,s=[].slice;r=t(3),o=function(e){function n(){return n.__super__.constructor.apply(this,arguments)}return a(n,e),n.prototype.handleMethod=function(){var e,n;return n=arguments[0],e=2<=arguments.length?s.call(arguments,1):[],this.connection[n].apply(this.connection,e)},n.prototype.handleLogging=function(e){return this.handler=e,this.connection.logging.handleLog=function(e){return function(){return e.handleLog.apply(e,arguments)}}(this)},n}(r),e.exports=o},function(e,n){var t,r=[].slice;t=function(){function e(e){this.connection=e,this.proxyAPIMethods()}return e.prototype.proxyAPIMethods=function(e){var n,t,o;return null==e&&(e=[]),t=function(){var e,t;e=this.connection,t=[];for(n in e)o=e[n],"function"==typeof o&&t.push(n);return t}.call(this),t.forEach(function(e){return function(n){if("index"!==n)return e[n]=function(){return e.handleMethod.apply(e,[n].concat(r.call(arguments)))}}}(this))},e.prototype.index=function(e,n){return this.connection.createNamespaceForIndex(n,e,this)},e.prototype.handleLog=function(e){var n,t;if(this.handler){if(this.handler!==console)return this.handler(e);switch(t=e.type,n=e.data,t){case"transaction.start":return console.groupCollapsed(n);case"request":return console.log(n);case"transaction.end":return console.groupEnd()}}},e.prototype.proxyObjectStoresNamespace=function(e){return this.connection.createNamespaceForObjectStores(e,this)},e}(),e.exports=t},function(e,n,t){var r,o,a,i,s=function(e,n){return function(){return e.apply(n,arguments)}},u=function(e,n){function t(){this.constructor=e}for(var r in n)c.call(n,r)&&(e[r]=n[r]);return t.prototype=n.prototype,e.prototype=new t,e.__super__=n.prototype,e},c={}.hasOwnProperty,l=[].slice;r=t(3),o=t(5),i=t(6),a=function(e){function n(){this.handleMessage=s(this.handleMessage,this),n.__super__.constructor.apply(this,arguments),this.promises={},this.messages=[],this.id=1,this.spawnWorker()}return u(n,e),n.prototype.spawnWorker=function(){var e,n,t,r,a;return a=this.connection,r=a.name,t=a.migrations,e=new Blob([o,i]),n=window.URL.createObjectURL(e),this.worker=new Worker(n),this.worker.onmessage=this.handleMessage,this.worker.postMessage({method:"init",args:{name:r,migrations:t}}),console.info("Ndex: Worker for “"+r+"” spawned at "+n)},n.prototype.handleLogging=function(e){return this.handler=e,this.worker.postMessage({method:"handleLogging"})},n.prototype.createPromiseForId=function(e){return new Promise(function(n){return function(t,r){return n.promises[e]={id:e,resolve:t,reject:r}}}(this))},n.prototype.handleMethod=function(){var e,n,t,r;return t=arguments[0],e=2<=arguments.length?l.call(arguments,1):[],n=this.id++,r=this.createPromiseForId(n),this.messages.length||this.schedulePostMessage(),this.messages.push({id:n,method:t,args:e}),r},n.prototype.schedulePostMessage=function(){return setTimeout(function(e){return function(){var n;return n=e.messages.splice(0),e.worker.postMessage(n)}}(this),0)},n.prototype.handleMessage=function(e){var n,t,r,o,a,i,s;return a=e.data,t=a.id,s=a.resolve,i=a.reject,r=a.method,n=a.args,r?this[r](n):(o=this.promises[t],delete this.promises[t],"resolve"in e.data?o.resolve(s):o.reject(new Error(i)))},n}(r),e.exports=a},function(e,n){e.exports="var factory,\n  slice = [].slice;\n\nfactory = function() {\n  var Connection;\n  Connection = {};\n  Connection.API = (function() {\n    API.prototype.CONNECTION_TIMEOUT = 3000;\n\n    API.prototype.REQUEST_TIMEOUT = 3000;\n\n    function API(name1, migrations1) {\n      this.name = name1;\n      this.migrations = migrations1;\n      this.database = null;\n      this.queue = {};\n      this.logging = new Connection.Logging;\n    }\n\n    API.prototype.parseMigrations = function(migrations) {\n      var keys, version;\n      if (version = migrations.version) {\n        this.version = version;\n        delete migrations.version;\n      }\n      keys = Object.keys(migrations).sort();\n      return keys.map((function(_this) {\n        return function(key) {\n          var actions, title, titleMatches;\n          version = parseInt(key);\n          titleMatches = key.match(/_(.+)/);\n          title = titleMatches ? titleMatches[1].replace(/(\\w)([A-Z])/g, function($1, $2, $3) {\n            return $2 + \" \" + ($3.toLowerCase());\n          }) : '';\n          actions = migrations[key] || [];\n          if (!Array.isArray(actions)) {\n            actions = [actions];\n          }\n          return {\n            version: version,\n            title: title,\n            actions: actions,\n            key: key\n          };\n        };\n      })(this));\n    };\n\n    API.prototype.deleteDatabase = function() {\n      return new Promise((function(_this) {\n        return function(resolve) {\n          var request;\n          if (!_this.database) {\n            return resolve();\n          }\n          _this.close();\n          request = indexedDB.deleteDatabase(_this.database.name);\n          return request.onsuccess = function(e) {\n            return setTimeout((function() {\n              return resolve();\n            }), 0);\n          };\n        };\n      })(this));\n    };\n\n    API.prototype.open = function(arg) {\n      var withoutVersion;\n      withoutVersion = (arg != null ? arg : {}).withoutVersion;\n      if (this.dbPromise) {\n        return this.dbPromise;\n      }\n      return this.dbPromise = new Promise((function(_this) {\n        return function(resolve, reject) {\n          var e, migrations, request, version;\n          if (!self.indexedDB) {\n            return reject('indexedDB isn’t supported');\n          }\n          migrations = _this.parseMigrations(_this.migrations);\n          try {\n            version = withoutVersion ? void 0 : _this.version || migrations.length + 1;\n            request = indexedDB.open(_this.name, version);\n            if ((_this.CONNECTION_TIMEOUT != null) && _this.CONNECTION_TIMEOUT > -1) {\n              request.__timeout = setTimeout(function() {\n                request.__timedout = true;\n                return reject(new Error('Connection timed out'));\n              }, _this.CONNECTION_TIMEOUT);\n            }\n          } catch (error1) {\n            e = error1;\n            clearTimeout(request.__timeout);\n            return reject(e.message || e.name);\n          }\n          request.onupgradeneeded = function(e) {\n            var action, db, j, l, len, len1, migration, migrationTransaction, name1, ref, results1, transaction;\n            clearTimeout(request.__timeout);\n            if (request.__timedout) {\n              return;\n            }\n            db = e.target.result;\n            transaction = e.target.transaction;\n            migrationTransaction = new Connection.Migration(db, transaction);\n            migrationTransaction.createObjectStore('migrations', {\n              keyPath: 'version'\n            });\n            results1 = [];\n            for (j = 0, len = migrations.length; j < len; j++) {\n              migration = migrations[j];\n              ref = migration.actions;\n              for (l = 0, len1 = ref.length; l < len1; l++) {\n                action = ref[l];\n                if (typeof migrationTransaction[name1 = action.type] === \"function\") {\n                  migrationTransaction[name1].apply(migrationTransaction, action.args);\n                }\n              }\n              results1.push(transaction.objectStore('migrations').put(migration));\n            }\n            return results1;\n          };\n          request.onsuccess = function(e) {\n            var db, objectStoreNames;\n            clearTimeout(request.__timeout);\n            if (request.__timedout) {\n              return;\n            }\n            db = e.target.result;\n            objectStoreNames = [].slice.call(db.objectStoreNames);\n            _this.createNamespaceForObjectStores(objectStoreNames);\n            db.onversionchange = function() {\n              return _this.close();\n            };\n            _this.database = db;\n            return resolve(objectStoreNames);\n          };\n          return request.onerror = function(e) {\n            if (!withoutVersion && request.error.name === 'VersionError') {\n              _this.close();\n              return _this.open({\n                withoutVersion: true\n              }).then(resolve)[\"catch\"](reject);\n            }\n            return reject(request.error.message || request.error.name);\n          };\n        };\n      })(this));\n    };\n\n    API.prototype.close = function() {\n      if (this.dbPromise) {\n        delete this.dbPromise;\n      }\n      if (this.database) {\n        return this.database.close();\n      }\n    };\n\n    API.prototype.get = function(objectStoreName, key, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var promises;\n          if (Array.isArray(key)) {\n            promises = Promise.all(key.map(function(k) {\n              return _this.get(objectStoreName, k);\n            }));\n            return promises.then(resolve);\n          } else {\n            return _this.enqueue('read', objectStoreName, reject, function(transaction) {\n              var params;\n              _this.logging.addRequest(transaction, 'get', objectStoreName, indexName, {\n                key: key\n              });\n              params = {\n                method: 'get',\n                args: key,\n                transaction: transaction,\n                reject: reject,\n                objectStoreName: objectStoreName,\n                indexName: indexName\n              };\n              return _this.createRequest(params, function(e) {\n                var value;\n                value = e.target.result;\n                if (value === void 0) {\n                  value = null;\n                }\n                return resolve(value);\n              });\n            });\n          }\n        };\n      })(this));\n    };\n\n    API.prototype.getFirst = function(objectStoreName, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('read', objectStoreName, reject, function(transaction) {\n            var params;\n            _this.logging.addRequest(transaction, 'getFirst', objectStoreName, indexName);\n            params = {\n              method: 'openCursor',\n              transaction: transaction,\n              reject: reject,\n              objectStoreName: objectStoreName,\n              indexName: indexName\n            };\n            return _this.createRequest(params, function(e) {\n              var cursor, objectStore, request, value;\n              request = e.target;\n              objectStore = request.source;\n              if (!(cursor = request.result)) {\n                return resolve(null);\n              }\n              value = cursor.value;\n              if (!objectStore.keyPath) {\n                value._key = cursor.key;\n              }\n              return resolve(value);\n            });\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.getAll = function(objectStoreName, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('read', objectStoreName, reject, function(transaction) {\n            var params, results;\n            _this.logging.addRequest(transaction, 'getAll', objectStoreName, indexName);\n            results = [];\n            params = {\n              method: 'openCursor',\n              transaction: transaction,\n              reject: reject,\n              objectStoreName: objectStoreName,\n              indexName: indexName\n            };\n            return _this.createRequest(params, function(e) {\n              var cursor, objectStore, request, value;\n              request = e.target;\n              objectStore = request.source;\n              if (!(cursor = e.target.result)) {\n                return resolve(results);\n              }\n              value = cursor.value;\n              if (!objectStore.keyPath) {\n                value._key = cursor.key;\n              }\n              results.push(value);\n              return cursor[\"continue\"]();\n            });\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.count = function(objectStoreName, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('read', objectStoreName, reject, function(transaction) {\n            var params;\n            _this.logging.addRequest(transaction, 'count', objectStoreName, indexName);\n            params = {\n              method: 'count',\n              transaction: transaction,\n              reject: reject,\n              objectStoreName: objectStoreName,\n              indexName: indexName\n            };\n            return _this.createRequest(params, function(e) {\n              var value;\n              value = e.target.result;\n              if (!value) {\n                value = 0;\n              }\n              return resolve(value);\n            });\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.add = function(objectStoreName, key, data) {\n      var ref;\n      if (data === void 0) {\n        ref = [null, key], key = ref[0], data = ref[1];\n      }\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var promises;\n          if (!key && Array.isArray(data)) {\n            promises = Promise.all(data.map(function(d) {\n              return _this.add(objectStoreName, d);\n            }));\n            return promises.then(resolve);\n          } else if (key && Array.isArray(key) && Array.isArray(data)) {\n            promises = Promise.all(key.map(function(key, i) {\n              return _this.add(objectStoreName, key, data[i]);\n            }));\n            return promises.then(resolve);\n          } else {\n            return _this.enqueue('write', objectStoreName, reject, function(transaction) {\n              var args, params;\n              _this.logging.addRequest(transaction, 'add', objectStoreName, null, {\n                key: key,\n                data: data\n              });\n              args = key ? [data, key] : [data];\n              params = {\n                method: 'put',\n                args: args,\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                reject: reject\n              };\n              return _this.createRequest(params, function(e) {\n                data._key = e.target.result;\n                return resolve(data);\n              });\n            });\n          }\n        };\n      })(this));\n    };\n\n    API.prototype.update = function(objectStoreName, key, value) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('write', objectStoreName, reject, function(transaction) {\n            var params;\n            _this.logging.addRequest(transaction, 'update', objectStoreName, null, {\n              key: key,\n              data: value\n            });\n            params = {\n              method: 'get',\n              args: key,\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              reject: reject\n            };\n            return _this.createRequest(params, function(e) {\n              var args, data, deepUpdate, hasKeyPath, keyPath, objectStore, request;\n              request = e.target;\n              objectStore = request.source;\n              keyPath = objectStore.keyPath;\n              hasKeyPath = !!keyPath;\n              data = request.result;\n              if (data === void 0) {\n                data = value;\n                if (hasKeyPath) {\n                  data[keyPath] = key;\n                }\n              } else {\n                deepUpdate = function(o, root) {\n                  var k, results1, v;\n                  results1 = [];\n                  for (k in o) {\n                    v = o[k];\n                    if (typeof v === 'object') {\n                      deepUpdate(v, root[k]);\n                      continue;\n                    }\n                    results1.push(root[k] = v);\n                  }\n                  return results1;\n                };\n                deepUpdate(value, data);\n              }\n              args = hasKeyPath ? [data] : [data, key];\n              params = {\n                method: 'put',\n                args: args,\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                reject: reject\n              };\n              return _this.createRequest(params, function(e) {\n                return resolve(data);\n              });\n            });\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.increment = function(objectStoreName, key, value, decrement) {\n      if (value == null) {\n        value = 1;\n      }\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('write', objectStoreName, reject, function(transaction) {\n            var params;\n            _this.logging.addRequest(transaction, (decrement ? 'decrement' : 'increment'), objectStoreName, null, {\n              key: key,\n              data: value\n            });\n            params = {\n              method: 'get',\n              args: key,\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              reject: reject\n            };\n            return _this.createRequest(params, function(e) {\n              var args, data, deepIncrement, hasKeyPath, keyPath, objectStore, request;\n              request = e.target;\n              objectStore = request.source;\n              keyPath = objectStore.keyPath;\n              hasKeyPath = !!keyPath;\n              data = request.result;\n              if (hasKeyPath) {\n                deepIncrement = function(o, root) {\n                  var k, results1, v;\n                  results1 = [];\n                  for (k in o) {\n                    v = o[k];\n                    if (typeof v === 'object') {\n                      deepIncrement(v, root[k]);\n                      continue;\n                    }\n                    root[k] || (root[k] = 0);\n                    results1.push(root[k] += decrement ? -v : v);\n                  }\n                  return results1;\n                };\n                deepIncrement(value, data);\n              } else {\n                data || (data = 0);\n                data += decrement ? -value : value;\n              }\n              args = hasKeyPath ? [data] : [data, key];\n              params = {\n                method: 'put',\n                args: args,\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                reject: reject\n              };\n              return _this.createRequest(params, function(e) {\n                return resolve(data);\n              });\n            });\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.decrement = function(objectStoreName, key, value) {\n      return this.increment(objectStoreName, key, value, true);\n    };\n\n    API.prototype[\"delete\"] = function(objectStoreName, key) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var promises;\n          if (Array.isArray(key)) {\n            promises = Promise.all(key.map(function(k) {\n              return _this[\"delete\"](objectStoreName, k);\n            }));\n            return promises.then(resolve);\n          } else {\n            return _this.enqueue('write', objectStoreName, reject, function(transaction) {\n              var params;\n              _this.logging.addRequest(transaction, 'delete', objectStoreName, null, {\n                key: key\n              });\n              params = {\n                method: 'delete',\n                args: key,\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                reject: reject\n              };\n              return _this.createRequest(params, function(e) {\n                return resolve(key);\n              });\n            });\n          }\n        };\n      })(this));\n    };\n\n    API.prototype.deleteWhere = function(objectStoreName, predicates, indexName) {\n      predicates.remove = true;\n      return this.where(objectStoreName, predicates, indexName);\n    };\n\n    API.prototype.clear = function(objectStoreName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('write', objectStoreName, reject, function(transaction) {\n            var params;\n            _this.logging.addRequest(transaction, 'clear', objectStoreName);\n            params = {\n              method: 'clear',\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              reject: reject\n            };\n            return _this.createRequest(params, function(e) {\n              return resolve();\n            });\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.clearAll = function() {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var objectStoreNames, promises;\n          objectStoreNames = slice.call(_this.database.objectStoreNames);\n          objectStoreNames = objectStoreNames.filter(function(objectStoreName) {\n            return objectStoreName !== 'migrations';\n          });\n          promises = Promise.all(objectStoreNames.map(function(objectStoreName) {\n            return _this.clear(objectStoreName);\n          }));\n          promises.then(resolve);\n          return promises[\"catch\"](reject);\n        };\n      })(this));\n    };\n\n    API.prototype.reset = function(objectStoreName, key, data) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var clearPromise;\n          clearPromise = _this.clear(objectStoreName);\n          clearPromise[\"catch\"](reject);\n          return clearPromise.then(function() {\n            var addPromise;\n            addPromise = _this.add(objectStoreName, key, data);\n            addPromise[\"catch\"](reject);\n            return addPromise.then(resolve);\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.index = function(objectStoreName, indexName) {\n      return this.createNamespaceForIndex(indexName, objectStoreName);\n    };\n\n    API.prototype.where = function(objectStoreName, predicates, indexName) {\n      var readWrite;\n      readWrite = predicates.remove ? 'write' : 'read';\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue(readWrite, objectStoreName, reject, function(transaction) {\n            var args, bound, bounds, contains, count, eq, eqIsArray, exact, except, gt, gteq, hasValues, isEquivalent, isInclusive, isLowerBound, k, knownUniques, limit, lower, lt, lteq, offset, only, order, params, range, ref, remove, results, uniq, uniques, upper, v;\n            _this.logging.addRequest(transaction, 'where', objectStoreName, indexName, {\n              data: predicates\n            });\n            lt = predicates.lt, lteq = predicates.lteq, gt = predicates.gt, gteq = predicates.gteq, eq = predicates.eq, limit = predicates.limit, offset = predicates.offset, only = predicates.only, contains = predicates.contains, except = predicates.except, uniq = predicates.uniq, order = predicates.order, remove = predicates.remove;\n            uniques = Array.isArray(uniq) ? uniq : uniq ? [uniq] : [];\n            order = order === 'desc' ? 'prev' : 'next';\n            bounds = {};\n            ref = {\n              lt: lt,\n              lteq: lteq,\n              gt: gt,\n              gteq: gteq,\n              eq: eq\n            };\n            for (k in ref) {\n              v = ref[k];\n              if (v === void 0) {\n                continue;\n              }\n              isInclusive = k === 'gteq' || k === 'lteq';\n              isEquivalent = k === 'eq';\n              isLowerBound = k === 'gt' || k === 'gteq';\n              bound = isEquivalent ? 'exact' : isLowerBound ? 'lower' : 'upper';\n              bounds[bound] = {\n                value: v,\n                open: !isInclusive\n              };\n            }\n            range = null;\n            eqIsArray = false;\n            lower = bounds.lower, upper = bounds.upper, exact = bounds.exact;\n            if (exact) {\n              if (eqIsArray = Array.isArray(eq)) {\n                eq.sort();\n                lower = {\n                  value: eq[0],\n                  open: false\n                };\n                upper = {\n                  value: eq[eq.length - 1],\n                  open: false\n                };\n                range = IDBKeyRange.bound(lower.value, upper.value, lower.open, upper.open);\n              } else {\n                range = IDBKeyRange.only(exact.value);\n              }\n            } else if (lower && upper) {\n              range = IDBKeyRange.bound(lower.value, upper.value, lower.open, upper.open);\n            } else if (lower) {\n              range = IDBKeyRange.lowerBound(lower.value, lower.open);\n            } else if (upper) {\n              range = IDBKeyRange.upperBound(upper.value, upper.open);\n            }\n            results = [];\n            count = 0;\n            knownUniques = {};\n            hasValues = function(object, k, v) {\n              if (!Array.isArray(v)) {\n                v = [v];\n              }\n              return v.indexOf(object[k]) !== -1;\n            };\n            args = range ? [range, order] : void 0;\n            params = {\n              method: 'openCursor',\n              args: args,\n              transaction: transaction,\n              reject: reject,\n              objectStoreName: objectStoreName,\n              indexName: indexName\n            };\n            return _this.createRequest(params, function(e) {\n              var a, cursor, j, knownValues, len, objectStore, request, value;\n              request = e.target;\n              objectStore = request.source;\n              if (!(cursor = e.target.result)) {\n                return resolve(results);\n              }\n              value = cursor.value;\n              if (eqIsArray) {\n                only || (only = {});\n                only[objectStore.keyPath] = eq;\n              }\n              for (k in only) {\n                v = only[k];\n                if (!hasValues(value, k, v)) {\n                  return cursor[\"continue\"]();\n                }\n              }\n              for (k in contains) {\n                v = contains[k];\n                if (!Array.isArray(v)) {\n                  v = [v];\n                }\n                a = value[k];\n                if (!Array.isArray(a)) {\n                  a = [a];\n                }\n                if (!_this.intersect(a, v).length) {\n                  return cursor[\"continue\"]();\n                }\n              }\n              for (k in except) {\n                v = except[k];\n                if (hasValues(value, k, v)) {\n                  return cursor[\"continue\"]();\n                }\n              }\n              for (j = 0, len = uniques.length; j < len; j++) {\n                k = uniques[j];\n                knownValues = knownUniques[k] || (knownUniques[k] = []);\n                if (knownValues.indexOf(value[k]) !== -1) {\n                  return cursor[\"continue\"]();\n                }\n                knownUniques[k].push(value[k]);\n              }\n              count++;\n              if (offset && count <= offset) {\n                return cursor[\"continue\"]();\n              }\n              results.push(value);\n              if (remove) {\n                cursor[\"delete\"]();\n              }\n              if (limit) {\n                if (typeof limit === 'function' && limit(results)) {\n                  return resolve(results);\n                } else if (limit === results.length) {\n                  return resolve(results);\n                }\n              }\n              return cursor[\"continue\"]();\n            });\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.getMethodsForObjectStore = function() {\n      return this._getMethodsForObjectStore || (this._getMethodsForObjectStore = ['get', 'getFirst', 'getAll', 'count', 'add', 'update', 'increment', 'decrement', 'delete', 'deleteWhere', 'clear', 'reset', 'index', 'where']);\n    };\n\n    API.prototype.getMethodsForIndex = function() {\n      return this._getMethodsForIndex || (this._getMethodsForIndex = ['get', 'getFirst', 'getAll', 'count', 'where', 'deleteWhere']);\n    };\n\n    API.prototype.createNamespaceForObjectStores = function(objectStoreNames, context) {\n      var j, len, objectStoreName, results1;\n      if (objectStoreNames == null) {\n        objectStoreNames = [];\n      }\n      if (context == null) {\n        context = this;\n      }\n      results1 = [];\n      for (j = 0, len = objectStoreNames.length; j < len; j++) {\n        objectStoreName = objectStoreNames[j];\n        if (objectStoreName === 'migrations') {\n          continue;\n        }\n        results1.push(this.createNamespaceForObjectStore(objectStoreName, context));\n      }\n      return results1;\n    };\n\n    API.prototype.createNamespaceForObjectStore = function(objectStoreName, context) {\n      var namespace;\n      if (context == null) {\n        context = this;\n      }\n      namespace = context[objectStoreName] = {};\n      this.getMethodsForObjectStore().forEach((function(_this) {\n        return function(method) {\n          return namespace[method] = function() {\n            return context[method].apply(context, [objectStoreName].concat(slice.call(arguments)));\n          };\n        };\n      })(this));\n      return namespace;\n    };\n\n    API.prototype.createNamespaceForIndex = function(indexName, objectStoreName, context) {\n      var namespace;\n      if (context == null) {\n        context = this;\n      }\n      namespace = {};\n      this.getMethodsForIndex().forEach((function(_this) {\n        return function(method) {\n          return namespace[method] = function() {\n            return context[method].apply(context, [objectStoreName].concat(slice.call(arguments), [indexName]));\n          };\n        };\n      })(this));\n      return namespace;\n    };\n\n    API.prototype.getObjectStore = function(arg) {\n      var indexName, objectStore, objectStoreName, transaction;\n      transaction = arg.transaction, objectStoreName = arg.objectStoreName, indexName = arg.indexName;\n      objectStore = transaction.objectStore(objectStoreName);\n      if (indexName) {\n        return objectStore.index(indexName);\n      } else {\n        return objectStore;\n      }\n    };\n\n    API.prototype.createRequest = function(arg, callback) {\n      var args, indexName, method, objectStore, objectStoreName, reject, request, transaction;\n      method = arg.method, args = arg.args, transaction = arg.transaction, objectStoreName = arg.objectStoreName, indexName = arg.indexName, reject = arg.reject;\n      objectStore = transaction.objectStore(objectStoreName);\n      if (indexName) {\n        objectStore = objectStore.index(indexName);\n      }\n      if (!Array.isArray(args)) {\n        args = [args];\n      }\n      request = objectStore[method].apply(objectStore, args);\n      if ((this.REQUEST_TIMEOUT != null) && this.REQUEST_TIMEOUT > -1) {\n        request.__timeout = setTimeout(function() {\n          request.__timedout = true;\n          return typeof reject === \"function\" ? reject(new Error('Request timed out')) : void 0;\n        }, this.REQUEST_TIMEOUT);\n      }\n      request.onsuccess = function(e) {\n        clearTimeout(request.__timeout);\n        if (request.__timedout) {\n          return;\n        }\n        return callback(e);\n      };\n      request.onerror = function(e) {\n        clearTimeout(request.__timeout);\n        if (request.__timedout) {\n          return;\n        }\n        return typeof reject === \"function\" ? reject(request.error) : void 0;\n      };\n      return request;\n    };\n\n    API.prototype.createTransaction = function(mode, objectStoreName, callback) {\n      return this.open().then((function(_this) {\n        return function() {\n          var error, transaction;\n          try {\n            transaction = _this.database.transaction([objectStoreName], mode);\n          } catch (error1) {\n            error = error1;\n          }\n          return callback(transaction);\n        };\n      })(this))[\"catch\"]((function(_this) {\n        return function(err) {\n          throw err;\n        };\n      })(this));\n    };\n\n    API.prototype.intersect = function(a, b) {\n      var ai, bi, result;\n      ai = 0;\n      bi = 0;\n      result = [];\n      while (ai < a.length && bi < b.length) {\n        if (a[ai] < b[bi]) {\n          ai++;\n        } else if (a[ai] > b[bi]) {\n          bi++;\n        } else {\n          result.push(a[ai]);\n          ai++;\n          bi++;\n        }\n      }\n      return result;\n    };\n\n    API.prototype.enqueue = function(readwrite, objectStoreName, reject, callback) {\n      var base, request;\n      (base = this.queue)[objectStoreName] || (base[objectStoreName] = []);\n      request = {\n        readwrite: readwrite,\n        objectStoreName: objectStoreName,\n        reject: reject,\n        callback: callback\n      };\n      if (!this.queue[objectStoreName].length) {\n        this.scheduleTransaction(objectStoreName);\n      }\n      return this.queue[objectStoreName].push(request);\n    };\n\n    API.prototype.scheduleTransaction = function(objectStoreName) {\n      return setTimeout((function(_this) {\n        return function() {\n          var mode, modes, needsWriteMode, requests;\n          requests = _this.queue[objectStoreName].splice(0);\n          modes = requests.map(function(r) {\n            return r.readwrite;\n          });\n          needsWriteMode = modes.some(function(m) {\n            return m === 'write';\n          });\n          mode = needsWriteMode ? 'readwrite' : 'readonly';\n          return _this.createTransaction(mode, objectStoreName, function(transaction) {\n            var err, j, len, request, results1;\n            _this.logging.addTransaction(transaction, objectStoreName);\n            results1 = [];\n            for (j = 0, len = requests.length; j < len; j++) {\n              request = requests[j];\n              try {\n                results1.push(request.callback(transaction));\n              } catch (error1) {\n                err = error1;\n                results1.push(request.reject(err));\n              }\n            }\n            return results1;\n          });\n        };\n      })(this), 0);\n    };\n\n    return API;\n\n  })();\n  Connection.Migration = (function() {\n    function Migration(db1, transaction1) {\n      this.db = db1;\n      this.transaction = transaction1;\n    }\n\n    Migration.prototype.createObjectStore = function(name, options) {\n      if (this.db.objectStoreNames.contains(name)) {\n        return;\n      }\n      return this.db.createObjectStore(name, options);\n    };\n\n    Migration.prototype.deleteObjectStore = function(name) {\n      if (!this.db.objectStoreNames.contains(name)) {\n        return;\n      }\n      return this.db.deleteObjectStore(name);\n    };\n\n    Migration.prototype.createIndex = function(objectStoreName, indexName, keyPath, options) {\n      var objectStore;\n      objectStore = this.transaction.objectStore(objectStoreName);\n      if (objectStore && objectStore.indexNames.contains(indexName)) {\n        return;\n      }\n      return objectStore.createIndex(indexName, keyPath, options);\n    };\n\n    Migration.prototype.deleteIndex = function(objectStoreName, indexName) {\n      var objectStore;\n      objectStore = this.transaction.objectStore(objectStoreName);\n      if (!(objectStore && objectStore.indexNames.contains(indexName))) {\n        return;\n      }\n      return objectStore.deleteIndex(indexName);\n    };\n\n    return Migration;\n\n  })();\n  Connection.Logging = (function() {\n    function Logging() {\n      this.queues = [];\n    }\n\n    Logging.prototype.addTransaction = function(transaction, objectStoreNames) {\n      var callback;\n      if (!(transaction && this.handleLog)) {\n        return;\n      }\n      this.queues.push({\n        transaction: transaction,\n        objectStoreNames: objectStoreNames,\n        requests: [],\n        start: Date.now()\n      });\n      callback = (function(_this) {\n        return function(e) {\n          return _this.logTransaction(e.target);\n        };\n      })(this);\n      transaction.onabort = callback;\n      transaction.onerror = callback;\n      return transaction.oncomplete = callback;\n    };\n\n    Logging.prototype.addRequest = function(transaction, method, objectStoreName, indexName, data) {\n      var queue;\n      if (!(transaction && this.handleLog)) {\n        return;\n      }\n      queue = this.queues.filter(function(q) {\n        return q.transaction === transaction;\n      })[0];\n      if (!queue) {\n        return;\n      }\n      return queue.requests.push({\n        method: method,\n        objectStoreName: objectStoreName,\n        indexName: indexName,\n        data: data\n      });\n    };\n\n    Logging.prototype.logTransaction = function(transaction) {\n      var data, end, indexName, j, key, len, logs, method, mode, objectStoreName, queue, ref, ref1, request, requestsLenght, time;\n      if (!(transaction && this.handleLog)) {\n        return;\n      }\n      queue = this.queues.filter(function(q) {\n        return q.transaction === transaction;\n      })[0];\n      if (!queue) {\n        return;\n      }\n      mode = queue.transaction.mode === 'readwrite' ? 'write' : 'read ';\n      requestsLenght = queue.requests.length;\n      end = Date.now();\n      time = end - queue.start;\n      this.handleLog({\n        type: 'transaction.start',\n        data: \"Ndex: \" + mode + \" \" + queue.objectStoreNames + \" \" + time + \"ms (\" + requestsLenght + \" request\" + (requestsLenght > 1 ? 's' : '') + \")\"\n      });\n      ref = queue.requests;\n      for (j = 0, len = ref.length; j < len; j++) {\n        request = ref[j];\n        method = request.method, objectStoreName = request.objectStoreName, indexName = request.indexName, data = request.data;\n        if (data) {\n          ref1 = data, key = ref1.key, data = ref1.data;\n        }\n        logs = [];\n        switch (method) {\n          case 'get':\n            logs = ['GET', key, 'FROM', objectStoreName];\n            break;\n          case 'getFirst':\n            logs = ['GET FIRST', key, 'FROM', objectStoreName];\n            break;\n          case 'getAll':\n            logs = ['GET ALL', 'FROM', objectStoreName];\n            break;\n          case 'count':\n            logs = ['COUNT', 'FROM', objectStoreName];\n            break;\n          case 'add':\n            logs = ['ADD', JSON.stringify(data), 'TO', objectStoreName];\n            if (key) {\n              logs = logs.concat(['WITH KEY', key]);\n            }\n            break;\n          case 'update':\n            logs = ['UPDATE', key, 'FROM', objectStoreName, 'SET', JSON.stringify(data)];\n            break;\n          case 'increment':\n            if (typeof data === 'object') {\n              data = JSON.stringify(data);\n            }\n            logs = ['INCREMENT', data, 'TO KEY', key, 'FROM', objectStoreName];\n            break;\n          case 'decrement':\n            if (typeof data === 'object') {\n              data = JSON.stringify(data);\n            }\n            logs = ['DECREMENT', data, 'TO KEY', key, 'FROM', objectStoreName];\n            break;\n          case 'delete':\n            logs = ['DELETE', key, 'FROM', objectStoreName];\n            break;\n          case 'clear':\n            logs = ['CLEAR', objectStoreName];\n            break;\n          case 'where':\n            if (typeof data.limit === 'function') {\n              data.limit = '[FUNCTION]';\n            }\n            logs = ['WHERE', JSON.stringify(data), 'FROM', objectStoreName];\n        }\n        if (indexName) {\n          logs = logs.concat(['INDEX', indexName]);\n        }\n        this.handleLog({\n          type: 'request',\n          data: logs.join(' ')\n        });\n      }\n      return this.handleLog({\n        type: 'transaction.end'\n      });\n    };\n\n    return Logging;\n\n  })();\n  return Connection.API;\n};\n\nif (typeof exports !== 'undefined') {\n  module.exports = factory();\n} else {\n  this.Connection = factory();\n}\n";
},function(e,n){e.exports="var handleLogging, init;\n\ninit = function(arg) {\n  var migrations, name;\n  name = arg.name, migrations = arg.migrations;\n  return this.connection = new Connection(name, migrations);\n};\n\nhandleLogging = function() {\n  return this.connection.logging.handleLog = function(args) {\n    return postMessage({\n      method: 'handleLog',\n      args: args\n    });\n  };\n};\n\nself.onmessage = (function(_this) {\n  return function(e) {\n    var data;\n    data = e.data;\n    if (!Array.isArray(data)) {\n      data = [data];\n    }\n    return data.forEach(function(datum) {\n      var args, id, method;\n      id = datum.id, method = datum.method, args = datum.args;\n      if (typeof _this[method] === 'function') {\n        return _this[method](args);\n      }\n      return _this.connection[method].apply(_this.connection, args).then(function(data) {\n        return postMessage({\n          id: id,\n          resolve: data\n        });\n      })[\"catch\"](function(data) {\n        return postMessage({\n          id: id,\n          reject: data\n        });\n      });\n    });\n  };\n})(this);\n"}])});